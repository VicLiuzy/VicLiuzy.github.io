<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>What happened</title>
  
  <subtitle>hello world</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-08-28T02:10:00.241Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Vic Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>写在100天</title>
    <link href="http://yoursite.com/2021/08/28/%E5%86%99%E5%9C%A8100%E5%A4%A9/"/>
    <id>http://yoursite.com/2021/08/28/写在100天/</id>
    <published>2021-08-28T15:03:00.000Z</published>
    <updated>2021-08-28T02:10:00.241Z</updated>
    
    <content type="html"><![CDATA[<p>亲爱的<strong>灯</strong> ❤️，</p><p>时间过得真快，明天就是我们在一起的第100天啦！<br>我们也从初夏走到初秋，共同度过了一个美好的夏天。<br>这个夏天的甜，值得我们永远记在心里。</p><p>灯灯，收到你的回信我好开心，没想到通信的感觉是这么奇妙。<br>在即时通讯如此发达的年代里，我们能够成为“笔友”，也是一种独特的体验呢！<br>你说很喜欢和我一起包饺子，我也是的！<br>而且没想到时隔一周，我们又有机会在一起包饺子。<br>这两次我都吃的好撑，因为实在是太好吃了，我觉得只要是灯灯做的都会很好吃，当然阿姨拌的馅儿也功不可没哈哈。</p><p>见不到你的日子，总是很想你，<br>“想念你的笑,想念你的外套,想念你白色袜子,和你身上的味道”。<br>上班的时候甚至会想你想到傻笑，不过放心，不会影响工作进度的，嘻嘻。<br>即将到来的九月，你也即将开始明年编制考试的备考。<br>虽然见面可能会减少，但我的思念和爱意将会更浓。<br>灯灯，我对你有信心，我相信这只是彩虹之前的小风雨而已，你一定可以上岸的，你也要相信自己！<br>你要记得我是你的依靠，是你坚实的后盾。<br>当你的肩膀累了，就换我来扛一会儿吧，这条路总会走到头的。</p><p>虽然之前那样整天腻在一起的机会可能少了，<br>但是当你学习累了的时候，我可以陪你吃顿饭犒劳一下自己；<br>寒冷的冬天，我可以晚上接你一起放学回家；<br>还可以互相直播一起学习。<br>这何尝不也是一种浪漫！<br>灯灯，我也经历过考研，虽然没有考编的竞争激烈，但是备考也是一样充实的。<br>我觉得备考的过程也是一种积极的体验，那种每天感觉到自己进步，时刻感觉到知识在向身体中灌输的状态，也是十分难忘的。<br>所以，忘掉焦虑吧，背水一战，享受这个过程，让后面的200天，也成为你和我的美好回忆。</p><p>面包会有的,牛奶会有的,一切都会好起来的，灯灯，期待我们下一个，下下一个…以及更多的100天！</p><p>永远爱你的<br><strong>宗</strong> ❤️</p><p>2021.08.28</p><blockquote><p>附：<a href="https://vicliuzy.github.io/Love/" target="_blank" rel="noopener">Our Love Story</a></p></blockquote><p><img src="/img/iloveyou.jfif" width="512" height="341"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;亲爱的&lt;strong&gt;灯&lt;/strong&gt; ❤️，&lt;/p&gt;
&lt;p&gt;时间过得真快，明天就是我们在一起的第100天啦！&lt;br&gt;我们也从初夏走到初秋，共同度过了一个美好的夏天。&lt;br&gt;这个夏天的甜，值得我们永远记在心里。&lt;/p&gt;
&lt;p&gt;灯灯，收到你的回信我好开心，没想到通信的感觉
      
    
    </summary>
    
      <category term="情书" scheme="http://yoursite.com/categories/%E6%83%85%E4%B9%A6/"/>
    
    
      <category term="情书" scheme="http://yoursite.com/tags/%E6%83%85%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>回顾单例模式</title>
    <link href="http://yoursite.com/2020/09/12/%E5%9B%9E%E9%A1%BE%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/09/12/回顾单例模式/</id>
    <published>2020-09-12T10:30:00.000Z</published>
    <updated>2020-09-12T05:57:02.036Z</updated>
    
    <content type="html"><![CDATA[<p>C++岗位面试中，面试官常常会问道，你常用哪些设计模式。我通常会回答：单例模式、策略模式、工厂模式、模板方法模式等。<br>其中单例模式实现方法比较固定，面试官有时会让我手写单例模式。为了在面试中能够准确无误的写出单例模式，本文对单例模式的C++实现进行回顾与总结。  </p><h2 id="单例模式的定义"><a href="#单例模式的定义" class="headerlink" title="单例模式的定义"></a>单例模式的定义</h2><p>让类负责保存其自己的实例，提供一个方法（全局访问点）获取该实例，并且不能从外部创建该类的其他实例，确保该类只有一个实例。</p><ul><li>为什么要使用单例模式，使用全局静态变量不可以吗？<br>全局变量无法保证只有一个实例，因此单例模式有其存在的必要。</li></ul><h2 id="单例模式的实现方式"><a href="#单例模式的实现方式" class="headerlink" title="单例模式的实现方式"></a>单例模式的实现方式</h2><p>单例模式通常有两种实现方式，分为<code>“懒汉式实现”</code>与<code>“饿汉式实现”</code>。它们的区别在于创建实例的时机。  </p><ul><li>懒汉式实现：只有需要获取实例时才创建实例。适用于不确定是否需要访问实例的情形，且实例访问非常少。</li><li>饿汉式实现：程序运行后立即创建实例。适用于需要频繁访问<code>getInst</code>的情形。相当于用空间换时间。</li></ul><h2 id="饿汉模式的单例模式"><a href="#饿汉模式的单例模式" class="headerlink" title="饿汉模式的单例模式"></a>饿汉模式的单例模式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;m_inst;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton();</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton m_inst;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton Singleton::m_inst;</span><br></pre></td></tr></table></figure><h2 id="懒汉模式的单例模式"><a href="#懒汉模式的单例模式" class="headerlink" title="懒汉模式的单例模式"></a>懒汉模式的单例模式</h2><h3 id="非线程安全实现"><a href="#非线程安全实现" class="headerlink" title="非线程安全实现"></a>非线程安全实现</h3><p>这是《设计模式》一书中的实现方式，是一种线程不安全的实现方式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_inst) &#123;</span><br><span class="line">            m_inst = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_inst;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton();</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个用于释放实例的内部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Garbo</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Garbo() &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        ~Garbo() &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_inst) &#123;</span><br><span class="line">                <span class="keyword">delete</span> m_inst;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton *m_inst;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Singleton *Singleton::m_inst = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">static</span> Singleton::Garbo Singleton::m_grabo;</span><br></pre></td></tr></table></figure><p>上述代码的Garbo类使代码十分臃肿，考虑用智能指针替代：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_inst) &#123;</span><br><span class="line">            m_inst = make_shared&lt;Singleton&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_inst.get();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton();</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">shared_ptr</span>&lt;Singleton&gt; m_inst;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">shared_ptr</span>&lt;Singleton&gt; Singleton::m_inst;</span><br></pre></td></tr></table></figure><h3 id="双重检查实现"><a href="#双重检查实现" class="headerlink" title="双重检查实现"></a>双重检查实现</h3><p>上述实现中，没有考虑多线程访问的情形。<br>下面先实现一个虽然加锁保护，但是效率极低的版本。<br>该版本中每次调用<code>getInst</code>都要访问互斥锁。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock_guard(m_mutexInst);</span><br><span class="line">        <span class="keyword">if</span> (!m_inst) &#123;</span><br><span class="line">            m_inst = make_shared&lt;Singleton&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_inst.get();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton();</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">shared_ptr</span>&lt;Singleton&gt; m_inst;</span><br><span class="line">    <span class="keyword">static</span> mutex m_mutexInst;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">shared_ptr</span>&lt;Singleton&gt; Singleton::m_inst;</span><br><span class="line"><span class="keyword">static</span> mutex Singleton::m_mutexInst;</span><br></pre></td></tr></table></figure><p>如果先进行实例判断，再进入互斥锁，是否可行呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_inst) &#123;</span><br><span class="line">            lock_guard(m_mutexInst);</span><br><span class="line">            m_inst = make_shared&lt;Singleton&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_inst.get();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton();</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">shared_ptr</span>&lt;Singleton&gt; m_inst;</span><br><span class="line">    <span class="keyword">static</span> mutex m_mutexInst;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">shared_ptr</span>&lt;Singleton&gt; Singleton::m_inst;</span><br><span class="line"><span class="keyword">static</span> mutex Singleton::m_mutexInst;</span><br></pre></td></tr></table></figure><p>思考一下两个线程同时进入<code>if</code>语句的情况，会发现实例被创建了两次，此时引起了内存泄漏，因此该实现是错误的。</p><p>下面是双重检查的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_inst) &#123;</span><br><span class="line">            lock_guard(m_mutexInst);</span><br><span class="line">            <span class="keyword">if</span> (!m_inst) &#123;</span><br><span class="line">                m_inst = make_shared&lt;Singleton&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_inst.get();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton();</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">shared_ptr</span>&lt;Singleton&gt; m_inst;</span><br><span class="line">    <span class="keyword">static</span> mutex m_mutexInst;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">shared_ptr</span>&lt;Singleton&gt; Singleton::m_inst;</span><br><span class="line"><span class="keyword">static</span> mutex Singleton::m_mutexInst;</span><br></pre></td></tr></table></figure><p>可以看出这个实现非常臃肿，而且它也并非完美。<br>根据《程序员的自我修养–链接、装载与库》一书，p29上的描述，CPU的乱序执行会导致一些问题。<br>主要是由于new的三个阶段也并非是原子的：  </p><ol><li>申请内存  </li><li>在该内存上调用构造函数</li><li>将内存地址反回</li></ol><p>问题在于二三步是可以颠倒的。会出现以下情况：<br>线程A中的<code>m_inst = new Singleton()</code>已执行第三步，却未执行第二步，此时调度到线程B，判断<code>m_inst</code>为非空，并返回该指针，此时<code>m_inst</code>上的操作可能引起崩溃问题。</p><h3 id="局部静态对象实现"><a href="#局部静态对象实现" class="headerlink" title="局部静态对象实现"></a>局部静态对象实现</h3><p>下面是被称为<code>Meyers&#39; Singleton</code>的单例实现，使用一个局部的static变量保存单例实例。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Singleton&amp; <span class="title">getInst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Singleton inst;</span><br><span class="line">        <span class="keyword">return</span> inst;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton();</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该实现是由著名的写出《Effective C++》系列书籍的作者Meyers提出的。所用到的特性是在<code>C++11</code>标准中的<code>Magic Static</code>特性：</p><blockquote><p>If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.<br>如果当变量在初始化的时候，并发同时进入声明语句，并发线程将会阻塞等待初始化结束。  </p></blockquote><p>这样保证了并发线程在获取静态局部变量的时候一定是初始化过的，所以具有线程安全性。  </p><p>C++静态变量的生存期 是从声明到程序结束，这也是一种懒汉式。  </p><p>这是最推荐的一种单例实现方式：</p><ol><li>通过局部静态变量的特性保证了线程安全 (C++11, GCC &gt; 4.3, VS2015支持该特性);</li><li>不需要使用共享指针，代码简洁；</li><li>注意在使用的时候需要声明单例的引用 Single&amp; 才能获取对象。</li></ol><p>如果想在<code>C++11</code>标准之前使用局部静态变量方式的单例模式，可以怎么做呢？恐怕必须要加锁保护静态变量的初始化了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Singleton&amp; <span class="title">getInst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mutex.lock()</span><br><span class="line">        <span class="keyword">static</span> Singleton inst;</span><br><span class="line">        mutex.unlock();</span><br><span class="line">        <span class="keyword">return</span> inst;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton();</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 不要在意这些细节</span></span><br><span class="line">    <span class="keyword">static</span> mutex m_mutexInst;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> mutex Singleton::m_mutexInst;</span><br></pre></td></tr></table></figure><p>参考文献：</p><p><a href="https://www.cnblogs.com/sunchaothu/p/10389842.html" target="_blank" rel="noopener">C++ 单例模式总结与剖析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C++岗位面试中，面试官常常会问道，你常用哪些设计模式。我通常会回答：单例模式、策略模式、工厂模式、模板方法模式等。&lt;br&gt;其中单例模式实现方法比较固定，面试官有时会让我手写单例模式。为了在面试中能够准确无误的写出单例模式，本文对单例模式的C++实现进行回顾与总结。  &lt;/
      
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>非递归方式遍历二叉树</title>
    <link href="http://yoursite.com/2020/09/05/%E9%9D%9E%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2020/09/05/非递归方式遍历二叉树/</id>
    <published>2020-09-05T10:14:00.000Z</published>
    <updated>2020-09-05T04:15:35.669Z</updated>
    
    <content type="html"><![CDATA[<p>非递归遍历二叉树，其基本思想是借助栈实现二叉树的遍历。本文回顾leetcode上给出的巧妙的一种相同算法解决先序、中序、后序的解法。</p><h2 id="基础先序遍历"><a href="#基础先序遍历" class="headerlink" title="基础先序遍历"></a>基础先序遍历</h2><p>先序遍历二叉树的顺序为“父节点-左孩子-右孩子”，先给出二叉树的数据结构声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Definition for a binary tree node.</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">     <span class="keyword">int</span> val;</span><br><span class="line">     TreeNode *left;</span><br><span class="line">     TreeNode *right;</span><br><span class="line">     TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>递归方式先序遍历二叉树：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rlt;</span><br><span class="line">        </span><br><span class="line">        recursion(root, rlt);</span><br><span class="line">        <span class="keyword">return</span> rlt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recursion</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rlt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rlt.push_back(root-&gt;val);</span><br><span class="line">        recursion(root-&gt;left, rlt);</span><br><span class="line">        recursion(root-&gt;right, rlt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用栈来迭代遍历二叉树，其基本思想为，每次迭代，栈顶元素出栈，并进行遍历，然后依次将其右孩子、左孩子入栈。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rlt;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> rlt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; assist;</span><br><span class="line">        assist.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!assist.empty()) &#123;</span><br><span class="line">            TreeNode* curNode = assist.top();</span><br><span class="line">            assist.pop();</span><br><span class="line">            rlt.push_back(curNode-&gt;val);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (curNode-&gt;right) &#123;</span><br><span class="line">                assist.push(curNode-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (curNode-&gt;left) &#123;</span><br><span class="line">                assist.push(curNode-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rlt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="分析如何实现统一的先中后遍历算法"><a href="#分析如何实现统一的先中后遍历算法" class="headerlink" title="分析如何实现统一的先中后遍历算法"></a>分析如何实现统一的先中后遍历算法</h2><p>仔细考虑先序、中序、后续遍历的区别，它们的区别仅仅在于何时获取元素。<br>我们用迭代去模拟递归，来实现二叉树的遍历。<br>用栈遍历二叉树的整体顺序是确定的，我们先访问左子树，后访问右子树，因此右子树先入栈，左子树后入栈，如果不访问节点的话，最简的遍历方式应该是下面这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Traversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; assist;</span><br><span class="line">        assist.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!assist.empty()) &#123;</span><br><span class="line">            TreeNode* curNode = assist.top();</span><br><span class="line">            assist.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (curNode-&gt;right) &#123;</span><br><span class="line">                assist.push(curNode-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (curNode-&gt;left) &#123;</span><br><span class="line">                assist.push(curNode-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相当于如下递归代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Traversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Traversal(root-&gt;left);</span><br><span class="line">        Traversal(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们看到该算法中，只要确定何时获取元素，就可以改造为先序、中序、后序遍历。</p><ul><li>对于先序遍历而言，先处理父节点，再处理左子树和右子树，其顺序为<code>父节点-左子树-右子树</code>。</li><li>对于中序遍历而言，处理父节点时，意味着左子树已全部处理完毕，但右子树尚未处理，其顺序为<code>左子树-父节点-右子树</code>。</li><li>对于后序遍历而言，处理父节点时，意味着左右子树都已全部处理完毕，其顺序为<code>左子树-右子树-父节点</code>。</li></ul><p>用栈来处理遍历二叉树问题时，栈顶元素先处理，栈底元素后处理，因此三种遍历方式必须保证栈内元素有如下顺序：</p><ul><li>先序，父节点在栈顶，然后是左孩子、右孩子。</li><li>中序，左孩子在栈顶，然后是父节点、右孩子。</li><li>后序，左孩子在栈顶，然后是右孩子、父节点。</li></ul><p>基于以上思路，我们使用一个空节点作为父节点的标记，实现了三种遍历算法。<br>每遍历一个节点，调整栈顶元素的位置，使其始终保持上述顺序，并在父节点上一层添加空节点进行标记。<br>当栈顶元素为空节点时，意味着次栈顶元素为需要访问的节点。</p><h2 id="改进后的先序遍历"><a href="#改进后的先序遍历" class="headerlink" title="改进后的先序遍历"></a>改进后的先序遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rlt;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> rlt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; assist;</span><br><span class="line">        assist.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!assist.empty()) &#123;</span><br><span class="line">            TreeNode* curNode = assist.top();</span><br><span class="line">            assist.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (curNode) &#123;</span><br><span class="line">                <span class="comment">// 保证父节点在栈顶，然后是左孩子、右孩子</span></span><br><span class="line">                <span class="keyword">if</span> (curNode-&gt;right) &#123;</span><br><span class="line">                    assist.push(curNode-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (curNode-&gt;left) &#123;</span><br><span class="line">                    assist.push(curNode-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                assist.push(curNode);</span><br><span class="line">                assist.push(<span class="literal">nullptr</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                rlt.push_back(assist.top()-&gt;val);</span><br><span class="line">                assist.pop();</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rlt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="改进后的中序遍历"><a href="#改进后的中序遍历" class="headerlink" title="改进后的中序遍历"></a>改进后的中序遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rlt;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> rlt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; assist;</span><br><span class="line">        assist.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!assist.empty()) &#123;</span><br><span class="line">            TreeNode* curNode = assist.top();</span><br><span class="line">            assist.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (curNode) &#123;</span><br><span class="line">                <span class="comment">// 保证左孩子在栈顶，然后是父节点、右孩子</span></span><br><span class="line">                <span class="keyword">if</span> (curNode-&gt;right) &#123;</span><br><span class="line">                    assist.push(curNode-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                assist.push(curNode);</span><br><span class="line">                assist.push(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (curNode-&gt;left) &#123;</span><br><span class="line">                    assist.push(curNode-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                rlt.push_back(assist.top()-&gt;val);</span><br><span class="line">                assist.pop();</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rlt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="改进后的后序遍历"><a href="#改进后的后序遍历" class="headerlink" title="改进后的后序遍历"></a>改进后的后序遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rlt;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> rlt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; assist;</span><br><span class="line">        assist.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!assist.empty()) &#123;</span><br><span class="line">            TreeNode* curNode = assist.top();</span><br><span class="line">            assist.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (curNode) &#123;</span><br><span class="line">                <span class="comment">// 保证左孩子在栈顶，然后是右孩子、父节点</span></span><br><span class="line">                assist.push(curNode);</span><br><span class="line">                assist.push(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (curNode-&gt;right) &#123;</span><br><span class="line">                    assist.push(curNode-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (curNode-&gt;left) &#123;</span><br><span class="line">                    assist.push(curNode-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                rlt.push_back(assist.top()-&gt;val);</span><br><span class="line">                assist.pop();</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rlt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;非递归遍历二叉树，其基本思想是借助栈实现二叉树的遍历。本文回顾leetcode上给出的巧妙的一种相同算法解决先序、中序、后序的解法。&lt;/p&gt;
&lt;h2 id=&quot;基础先序遍历&quot;&gt;&lt;a href=&quot;#基础先序遍历&quot; class=&quot;headerlink&quot; title=&quot;基础先序遍历
      
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="算法与数据结构" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>开启Hikey 970开发板USB AUDIO功能</title>
    <link href="http://yoursite.com/2020/05/10/%E8%AE%B0Android%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E4%B8%8E%E7%BC%96%E8%AF%91/"/>
    <id>http://yoursite.com/2020/05/10/记Android源码下载与编译/</id>
    <published>2020-05-10T15:26:07.000Z</published>
    <updated>2020-05-17T09:10:04.361Z</updated>
    
    <content type="html"><![CDATA[<p>4月30日，领导突然交给我一个任务，在Hikey970开发板上搭建录音环境。我只想说另请高明吧。我实在……我也不是谦虚，我一个上层应用开发怎么突然做起嵌入式来了呢？但是，领导讲“已经研究决定了”，后来我就念了两首诗，叫“苟利国家生死以，岂因祸福避趋之”。  </p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>领导还在跟我讨论买什么样的麦克风的时候，我突然在论坛中看到，<a href="http://smartfire.cn/thread-1177-1-2.html" target="_blank" rel="noopener">Hikey970开发板默认不支持<code>USB AUDIO</code></a>，需要修改内核配置开启。好嘛，还买个啥麦克风，先把音频输入调通再说吧。  </p><p>根据<a href="https://blog.csdn.net/u010164190/article/details/90699235?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=USB%20AUDIO&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduweb~default-8-90699235" target="_blank" rel="noopener">Android usb audio录音</a>这篇博文的介绍，打开<code>USB AUDIO</code>配置还是比较容易的，只需要修改<code>/kernel-4.9/sound/usb/Kconfig</code>文件中的<code>SND_USB_AUDIO</code>块即可。  </p><h2 id="下载AOSP源码"><a href="#下载AOSP源码" class="headerlink" title="下载AOSP源码"></a>下载AOSP源码</h2><p>还好我不是从零开始，前人已经总结了<a href="http://smartfire.cn/thread-1208-1-1.html" target="_blank" rel="noopener">源码编译AOSP详细步骤</a>。  </p><h3 id="用repo下载AOSP源码"><a href="#用repo下载AOSP源码" class="headerlink" title="用repo下载AOSP源码"></a>用repo下载AOSP源码</h3><h4 id="首先需要安装repo"><a href="#首先需要安装repo" class="headerlink" title="首先需要安装repo"></a>首先需要安装repo</h4><p>我使用WSL用<code>apt</code>命令安装，报错。<br>最后使用博客<a href="https://segmentfault.com/a/1190000015279330" target="_blank" rel="noopener">windows环境下repo下载Android源代码</a>中推荐的人修改好的repo客户端，<a href="https://codeload.github.com/esrlabs/git-repo/zip/stable" target="_blank" rel="noopener">点此下载</a>。  </p><h4 id="初始化repo仓库"><a href="#初始化repo仓库" class="headerlink" title="初始化repo仓库"></a>初始化repo仓库</h4><p>使用如下命令，以清华大学AOSP镜像仓库初始化repo：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-9.0.0_r8 --no-repo-verify --repo-branch=stable</span><br></pre></td></tr></table></figure><h4 id="开始下载源码"><a href="#开始下载源码" class="headerlink" title="开始下载源码"></a>开始下载源码</h4><p>论坛中使用如下命令进行repo仓库同步：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo sync -j4</span><br></pre></td></tr></table></figure><p><code>-j4</code>的含义为使用四线程进行仓库同步。<br>但由于AOSP源码过多，常常由于网络原因导致同步中断，报如下错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: error: Exited sync due to fetch errors</span><br></pre></td></tr></table></figure><p>因此需要加上强制同步的选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo sync -j4 -f --force-sync</span><br></pre></td></tr></table></figure><h3 id="下载过程中遇到的坑"><a href="#下载过程中遇到的坑" class="headerlink" title="下载过程中遇到的坑"></a>下载过程中遇到的坑</h3><h4 id="aux-h文件无法创建"><a href="#aux-h文件无法创建" class="headerlink" title="aux.h文件无法创建"></a><code>aux.h</code>文件无法创建</h4><p>开始我是在PowerShell环境进行的源码下载，但每当下载到<code>aux.h</code>文件时，就会报错文件无法被创建。经查资料，发现<code>aux</code>是Windows平台的保留文件名，无法被用户使用。不信你可以创建一个<code>aux.txt</code>试试。  </p><p>其实除aux之外，Windows还有许多预留文件名不能用，<a href="https://www.howtogeek.com/fyi/windows-10-still-wont-let-you-use-these-file-names-reserved-in-1974/" target="_blank" rel="noopener">这篇文章</a>做了很好的总结。</p><p>具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9</span><br></pre></td></tr></table></figure><p>在WSL环境进行<code>repo sync</code>，可以解决这个问题。  </p><h4 id="大小写不敏感导致的文件丢失"><a href="#大小写不敏感导致的文件丢失" class="headerlink" title="大小写不敏感导致的文件丢失"></a>大小写不敏感导致的文件丢失</h4><p>AOSP源码中，有许多源文件是除大小写外相同的，这样在Windows系统clone仓库时可能导致其中一个文件被当作重名文件丢失，或者在编译时会导致错误包含头文件 <em>（坑爹的Windows）</em>。</p><p>可通过如下python脚本批量设置目录下所有文件夹的文件大小写敏感：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">path = <span class="string">r'F:\\git_repo\\repo-tsinghua-linux\\tools'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> folderName, subfolders, fileNames <span class="keyword">in</span> os.walk(path):</span><br><span class="line">    os.system(<span class="string">'fsutil.exe file SetCaseSensitiveInfo '</span> + folderName + <span class="string">' enable'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Success!"</span>)</span><br></pre></td></tr></table></figure><p>也可在WSL下使用如下命令设置或获取目录是否大小写敏感（需要<code>apt install attr</code>）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 设置</span><br><span class="line">setfattr -n system.wsl_case_sensitive -v 1 "/mnt/f/git_repo/repo-tsinghua-linux/kernel/linux/net/netfilter"</span><br><span class="line"><span class="meta">#</span> 获取</span><br><span class="line">getfattr -n system.wsl_case_sensitive "/mnt/f/git_repo/repo-tsinghua-linux/kernel/linux/net/netfilter"</span><br></pre></td></tr></table></figure><p>可以通过上述方式先创建一个大小写敏感的目录，然后将代码仓库解压到该目录下，则新生成的目录都是大小写敏感的了。  </p><h2 id="下载并编译Hikey-970内核源码"><a href="#下载并编译Hikey-970内核源码" class="headerlink" title="下载并编译Hikey 970内核源码"></a>下载并编译Hikey 970内核源码</h2><h3 id="本地clone"><a href="#本地clone" class="headerlink" title="本地clone"></a>本地clone</h3><p>根据论坛的建议，原生的kernel不能boot这个版本的AOSP，会导致各种问题，需要重新clone linaro官方针对hikey970的kernel源码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/96boards-hikey/linux.git -b hikey970-v4.9 linux</span><br></pre></td></tr></table></figure><p>但国内的网络环境，clone github仓库只有20KBps的速度，下载这三四个GB的仓库要到猴年马月。</p><p>于是首先尝试挂代理，我的计算机上部署有V2ray的socks5代理，代理端口号为10808，于是使用如下命令进行git全局代理设置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 开启全局代理</span><br><span class="line">git config --global http.proxy 'socks5://127.0.0.1:10808'</span><br><span class="line">git config --global https.proxy 'socks5://127.0.0.1:10808'</span><br><span class="line"><span class="meta">#</span> 关闭全局代理</span><br><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><p>但设置代理后，像内核源码这么大的仓库，还是会失败。  </p><h3 id="VPS-clone"><a href="#VPS-clone" class="headerlink" title="VPS clone"></a>VPS clone</h3><p>在经历无数次的失败后，我直接使用VPS clone源码，然后用FTP协议将仓库打包传送到了本地。</p><h3 id="修改USB-AUDIO配置"><a href="#修改USB-AUDIO配置" class="headerlink" title="修改USB AUDIO配置"></a>修改USB AUDIO配置</h3><p>整个任务就是围绕这一步进行的，前文说过，打开USB AUDIO配置的方法为，只需要修改<code>/kernel-4.9/sound/usb/Kconfig</code>文件中的<code>SND_USB_AUDIO</code>块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">config SND_USB_AUDIO</span><br><span class="line">tristate &quot;USB Audio/MIDI driver&quot;</span><br><span class="line">select SND_HWDEP</span><br><span class="line">select SND_RAWMIDI</span><br><span class="line">select SND_PCM</span><br><span class="line">select BITREVERSE</span><br><span class="line"># 新增下面这行</span><br><span class="line">default y</span><br><span class="line"># 新增上面这行</span><br><span class="line">help</span><br><span class="line">  Say Y here to include support for USB audio and USB MIDI</span><br><span class="line">  devices.</span><br><span class="line"></span><br><span class="line">  To compile this driver as a module, choose M here: the module</span><br><span class="line">  will be called snd-usb-audio.</span><br></pre></td></tr></table></figure><h3 id="内核编译"><a href="#内核编译" class="headerlink" title="内核编译"></a>内核编译</h3><p>使用如下命令进行编译，注意需要目录大小写敏感。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd $AOSP_ROOT/kernel/linux</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 环境变量</span><br><span class="line">export ARCH=arm64</span><br><span class="line">export CROSS_COMPILE=$AOSP_ROOT/prebuilts/gcc/linux-x86/aarch64/aarch64-linux-android-4.9/bin/aarch64-linux-android-</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 编译Image</span><br><span class="line">make hikey970_defconfig &amp;&amp; make -j4 Image.gz modules</span><br><span class="line"><span class="meta">#</span> 生成kirin970-hikey970.dtb</span><br><span class="line">make hisilicon/kirin970-hikey970.dtb</span><br></pre></td></tr></table></figure><p>生成的目标为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>AOSP_ROOT/kernel/linux/arch/arm64/boot/dts/hisilicon/kirin970-hikey970.dts</span><br><span class="line"><span class="meta">$</span>AOSP_ROOT/kernel/linux/arch/arm64/boot/Image</span><br></pre></td></tr></table></figure><h2 id="生成系统镜像"><a href="#生成系统镜像" class="headerlink" title="生成系统镜像"></a>生成系统镜像</h2><p>其实，本次任务并不需要完整的编译整个AOSP，我们可以使用<a href="http://hihope.org/hihope/downLoadCenter/testDownFile?filename=20190403/hikey970_android_8_images.rar" target="_blank" rel="noopener">96boards官方提供的AOSP系统镜像</a>，只是替换其中的内核即可。</p><h3 id="AOSP-bootloader编译"><a href="#AOSP-bootloader编译" class="headerlink" title="AOSP/bootloader编译"></a>AOSP/bootloader编译</h3><p>我们跳过了AOSP编译这一步，实属无奈，120GB的硬盘都沾满了，实在放不下那么多目标文件。</p><p>同样，<code>bootloader</code>获取也跳过，直接用官方镜像。</p><p>AOSP编译生成的目标文件为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 即使是编译生成的boot.img，也需要手动替换其内核</span><br><span class="line"><span class="meta">$</span>AOSP_ROOT/out/target/product/hikey970/boot.img </span><br><span class="line"><span class="meta">$</span>AOSP_ROOT/out/target/product/hikey970/system.img</span><br><span class="line"><span class="meta">$</span>AOSP_ROOT/out/target/product/hikey970/cache.img</span><br><span class="line"><span class="meta">$</span>AOSP_ROOT/out/target/product/hikey970/userdata.img</span><br><span class="line"><span class="meta">$</span>AOSP_ROOT/out/target/product/hikey970/dt.img</span><br></pre></td></tr></table></figure><p>bootloader编译的产物为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>AOSP_ROOT/bootloader/l-loader/ptable-aosp-64g.img</span><br><span class="line"><span class="meta">$</span>AOSP_ROOT/bootloader/tools-images-hikey970/sec_xloader.img</span><br><span class="line"><span class="meta">$</span>AOSP_ROOT/bootloader/l-loader/l-loader.bin</span><br><span class="line"><span class="meta">$</span>AOSP_ROOT/bootloader/l-loader/fip.bin</span><br></pre></td></tr></table></figure><p>而我们下载的官方镜像目录下的文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">hikey970</span><br><span class="line">    ├── buildinfo.txt</span><br><span class="line">    ├── image</span><br><span class="line">    │   ├── Hikey970_download_images.xml</span><br><span class="line">    │   ├── boot.img</span><br><span class="line">    │   ├── boot_ramdisk.img</span><br><span class="line">    │   ├── cache.img</span><br><span class="line">    │   ├── dt.img</span><br><span class="line">    │   ├── fip.bin</span><br><span class="line">    │   ├── installed-files.txt</span><br><span class="line">    │   ├── kernel.img</span><br><span class="line">    │   ├── l-loader.bin</span><br><span class="line">    │   ├── lpm3.img</span><br><span class="line">    │   ├── prm_ptable.img</span><br><span class="line">    │   ├── ptable_for_fastboot.img</span><br><span class="line">    │   ├── ramdisk.img</span><br><span class="line">    │   ├── sec_usb_xloader.img</span><br><span class="line">    │   ├── sec_usb_xloader2.img</span><br><span class="line">    │   ├── sec_xloader.img</span><br><span class="line">    │   ├── system.img</span><br><span class="line">    │   ├── update_Hikey970.bat</span><br><span class="line">    │   ├── userdata.img</span><br><span class="line">    │   ├── uefi</span><br><span class="line">    │   │   ├── fip.bin</span><br><span class="line">    │   │   ├── l-loader.bin</span><br><span class="line">    │   │   ├── lpm3.img</span><br><span class="line">    │   │   ├── prm_ptable.img</span><br><span class="line">    │   │   ├── ptable_for_fastboot.img</span><br><span class="line">    │   │   ├── sec_usb_xloader.img</span><br><span class="line">    │   │   ├── sec_usb_xloader2.img</span><br><span class="line">    │   │   ├── sec_xloader.img</span><br><span class="line">    │   │   └── update_Hikey970.bat</span><br></pre></td></tr></table></figure><p>可以看到，所有目标文件都是存在的。</p><h3 id="重新打包boot-img"><a href="#重新打包boot-img" class="headerlink" title="重新打包boot.img"></a>重新打包<code>boot.img</code></h3><h4 id="解包boot-img"><a href="#解包boot-img" class="headerlink" title="解包boot.img"></a>解包<code>boot.img</code></h4><p>在<code>$AOSP_ROOT/system/core/mkbootimg</code>目录下，有着<code>unpack_bootimg</code>可执行程序，可以在WSL中运行，它可以将<code>boot.img</code>解包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unpackbootimg  -i  ./boot.img  -o ./output</span><br></pre></td></tr></table></figure><p>则会生成output目录，目录下有<code>boot</code>、<code>ramdisk</code>、<code>second</code>三个文件。其中，<code>boot</code>就是我们要替换的内核，而<code>ramdisk</code>包含了Andoroid系统的文件系统信息，这里不展开了。</p><h4 id="生成新boot"><a href="#生成新boot" class="headerlink" title="生成新boot"></a>生成新boot</h4><p>其实就是将内核编译的两个产物合并为一个：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat $AOSP_ROOT/kernel/linux/arch/arm64/boot/Image $AOSP_ROOT/kernel/linux/arch/arm64/boot/dts/hisilicon/kirin970-hikey970.dtb &gt; $AOSP_ROOT/Image-dtb</span><br></pre></td></tr></table></figure><h4 id="打包boot-img"><a href="#打包boot-img" class="headerlink" title="打包boot.img"></a>打包<code>boot.img</code></h4><p>将刚刚生成的<code>Image-dtb</code>也拷贝到<code>output</code>目录下，然后执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkbootimg --kernel ./output/Image-dtb --ramdisk ./output/ramdisk --cmdline "androidboot.hardware=hikey970 firmware_class.path=/system/etc/firmware loglevel=15 buildvariant=userdebug androidboot.selinux=permissive clk_ignore_unused=true initrd=0xBE19D000,0x16677F earlycon=pl011,0xfff32000,115200 console=ttyAMA6 androidboot.serialno=54DA9CD5022525E4 clk_ignore_unused=true" -o boot.img</span><br></pre></td></tr></table></figure><p>则生成了全新的<code>boot.img</code>。</p><h2 id="烧写"><a href="#烧写" class="headerlink" title="烧写"></a>烧写</h2><p>Windows环境下，执行<code>update_Hikey970.bat</code>即可。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>以<code>cat /proc/asound/cards</code>命令查看设备，果然有了USB AUDIO设备，成功~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;4月30日，领导突然交给我一个任务，在Hikey970开发板上搭建录音环境。我只想说另请高明吧。我实在……我也不是谦虚，我一个上层应用开发怎么突然做起嵌入式来了呢？但是，领导讲“已经研究决定了”，后来我就念了两首诗，叫“苟利国家生死以，岂因祸福避趋之”。  &lt;/p&gt;
&lt;h2
      
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="构建" scheme="http://yoursite.com/tags/%E6%9E%84%E5%BB%BA/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>合肥觅食</title>
    <link href="http://yoursite.com/2020/05/10/%E5%90%88%E8%82%A5%E8%A7%85%E9%A3%9F/"/>
    <id>http://yoursite.com/2020/05/10/合肥觅食/</id>
    <published>2020-05-10T11:03:07.000Z</published>
    <updated>2020-05-10T06:50:29.891Z</updated>
    
    <content type="html"><![CDATA[<p>在公司论坛看到的美食攻略，果断抄过来备忘  </p><h2 id="小吃"><a href="#小吃" class="headerlink" title="小吃"></a>小吃</h2><h3 id="官亭路小吃街"><a href="#官亭路小吃街" class="headerlink" title="官亭路小吃街"></a>官亭路小吃街</h3><ul><li>胖子肥肠，店面卫生一般，但味道不一般  </li><li>老北京鸡肉卷  </li><li>小杨生煎  </li><li>桂花汤圆  </li><li>眼镜铁板烧的烤鱿鱼（不知道现在还有没）  </li></ul><h3 id="嘎嘎鸭下巴"><a href="#嘎嘎鸭下巴" class="headerlink" title="嘎嘎鸭下巴"></a>嘎嘎鸭下巴</h3><p>位置：淮河路步行街，长江剧院旁边巷子往里走  </p><p>适合爱吃辣的筒子们，他们家不辣都有点辣，不过真的很香<br><em>P.S.看来与我无缘了</em></p><h3 id="鱼煲"><a href="#鱼煲" class="headerlink" title="鱼煲"></a>鱼煲</h3><p>位置：也是在长江剧院巷子里，巷子里有两家都可以去  </p><p>现在不清楚到底开了多少分店但最爱吃的还是这家老店，鱼肉做的很鲜嫩入味，但其它炒菜水平真的不敢恭维，去吃吃鱼逛逛街就好啦  </p><hr><h2 id="广东菜、粥品"><a href="#广东菜、粥品" class="headerlink" title="广东菜、粥品"></a>广东菜、粥品</h2><h3 id="煲王餐厅"><a href="#煲王餐厅" class="headerlink" title="煲王餐厅"></a>煲王餐厅</h3><p>位置：黄山路炮兵学院附近  </p><p>主打粤菜，<strong>猪肚鸡</strong>不错，里面各种小点心也可以随便点  </p><h3 id="煲宫"><a href="#煲宫" class="headerlink" title="煲宫"></a>煲宫</h3><p>位置：万象城商场里面  </p><p><strong>猪肚鸡</strong>很不错，可以试试   </p><h3 id="粥公馆"><a href="#粥公馆" class="headerlink" title="粥公馆"></a>粥公馆</h3><p>位置：在宁国路上  </p><p>爱喝粥可以试下，虽比不上去广州当地喝的过瘾，但在合肥也算做的用心的一家潮汕粥了   </p><hr><h2 id="日料、烤肉、串串"><a href="#日料、烤肉、串串" class="headerlink" title="日料、烤肉、串串"></a>日料、烤肉、串串</h2><h3 id="久旦日料"><a href="#久旦日料" class="headerlink" title="久旦日料"></a>久旦日料</h3><p>位置：天鹅湖银泰城  </p><p>日料里味道不错里面性价比高的，推荐<strong>海鲜玉子烧</strong>、<strong>各种寿司卷</strong>、<strong>鹅肝手握</strong>等，烤肉感觉一般，慎点。人均100左右  </p><h3 id="道烧肉酒场"><a href="#道烧肉酒场" class="headerlink" title="道烧肉酒场"></a>道烧肉酒场</h3><p>位置：黄山路1912  </p><p>烤肉一级棒，适合偶尔去解馋，环境也不错，需要提前预约，包厢紧张，里面肉根据钱包随便点，人均200左右，适合重大纪念日庆祝  </p><h3 id="延旭烧烤串城"><a href="#延旭烧烤串城" class="headerlink" title="延旭烧烤串城"></a>延旭烧烤串城</h3><p>位置：宁国路  </p><p>电烤串，配好料自己放上去转就行，大众点评可以提前预约，经常排队，科学大道也有家分店但感觉没宁国路点味道正，人均80左右，常年有118双人团购套餐和208四人团购套餐，也基本够吃了  </p><h3 id="耍串串串火锅"><a href="#耍串串串火锅" class="headerlink" title="耍串串串火锅"></a>耍串串串火锅</h3><p>位置： 1912<br>合肥很多分店了，最爱吃的还是1912那家，同样是人多，排队，人均七八十  </p><hr><h2 id="海鲜"><a href="#海鲜" class="headerlink" title="海鲜"></a>海鲜</h2><h3 id="闽南海鲜面馆"><a href="#闽南海鲜面馆" class="headerlink" title="闽南海鲜面馆"></a>闽南海鲜面馆</h3><p>位置：市三中旁边，苏州路与义仓巷交口  </p><p>海鲜面十几块钱一碗，汤很鲜，单点大虾、蛏子也很肥美新鲜，甜丝丝的那种，人均二三十</p><h3 id="福星家海鲜餐厅"><a href="#福星家海鲜餐厅" class="headerlink" title="福星家海鲜餐厅"></a>福星家海鲜餐厅</h3><p>位置：青阳路</p><p>老板是浙江一个小渔村的，自家渔船打捞上岸速冻后每天送到合肥，从一个微商小主到现在已经开了两家分店，食材真的很新鲜，推荐<strong>椒盐豆腐鱼</strong>、<strong>海鲜炒粉</strong>（提前点，要炒近半个多小时）、<strong>干贝冬瓜</strong>、<strong>爆炒章鱼</strong>、<strong>鸦片鱼头</strong>等，人均稍高，大概130左右</p><hr><h2 id="徽菜"><a href="#徽菜" class="headerlink" title="徽菜"></a>徽菜</h2><h3 id="刀板香"><a href="#刀板香" class="headerlink" title="刀板香"></a>刀板香</h3><p>位置：凤凰城金牛路附近  </p><p>推荐<strong>毛峰生焖鸡</strong>、<strong>皖南山猪肉焖面</strong>、<strong>石耳炒土鸡蛋</strong>等，里面菜基本都吃过，还没踩过雷，去晚了经常有菜品售罄</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在公司论坛看到的美食攻略，果断抄过来备忘  &lt;/p&gt;
&lt;h2 id=&quot;小吃&quot;&gt;&lt;a href=&quot;#小吃&quot; class=&quot;headerlink&quot; title=&quot;小吃&quot;&gt;&lt;/a&gt;小吃&lt;/h2&gt;&lt;h3 id=&quot;官亭路小吃街&quot;&gt;&lt;a href=&quot;#官亭路小吃街&quot; class=&quot;he
      
    
    </summary>
    
      <category term="杂谈" scheme="http://yoursite.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="美食" scheme="http://yoursite.com/tags/%E7%BE%8E%E9%A3%9F/"/>
    
  </entry>
  
  <entry>
    <title>Hello World, Gradle</title>
    <link href="http://yoursite.com/2018/11/15/Gradle%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/11/15/Gradle使用/</id>
    <published>2018-11-14T22:00:00.000Z</published>
    <updated>2020-05-10T07:06:47.169Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：为了跑通gradle，差点没费死劲，本文记录配置gradle过程中踩过的坑</p></blockquote><h2 id="gradle是什么，为什么要配置gradle"><a href="#gradle是什么，为什么要配置gradle" class="headerlink" title="gradle是什么，为什么要配置gradle"></a>gradle是什么，为什么要配置gradle</h2><p>Gradle是一个基于JVM的构建工具，是一款通用灵活的构建工具，支持maven，Ivy仓库，支持传递性依赖管理，而不需要远程仓库或者是pom.xml和ivy.xml配置文件，基于Groovy，build脚本使用Groovy编写。</p><p>以上内容来自百度百科，对于我来说，将编译好的so文件与java代码打包成apk文件必须使用gradle，对此我暂时只知道这么多。</p><h2 id="gradle安装"><a href="#gradle安装" class="headerlink" title="gradle安装"></a>gradle安装</h2><p>下载，解压，配置环境变量，无需多言。<br>值得注意的一点是<code>GRADLE_USER_HOME</code>这个环境变量可以修改缓存文件的位置，缓存文件还是很重要的，我被它坑惨了。<br>还有一些别的方法可以修改缓存文件位置，详见：<a href="https://blog.csdn.net/yanzi1225627/article/details/52024632" target="_blank" rel="noopener">https://blog.csdn.net/yanzi1225627/article/details/52024632</a> 。</p><h2 id="下载依赖项"><a href="#下载依赖项" class="headerlink" title="下载依赖项"></a>下载依赖项</h2><p>如果你是第一次使用gradle构建项目，需要下载很多依赖项。在执行这一步之前，首先要修改项目文件夹下<code>local.properties</code>与<code>build.gradle</code>两个文件。</p><h3 id="local-properties-–-本地ndk位置"><a href="#local-properties-–-本地ndk位置" class="headerlink" title="local.properties – 本地ndk位置"></a>local.properties – 本地ndk位置</h3><p>将<code>ndk.dir</code>修改为本地ndk存放的位置，将<code>sdk.dir</code>修改为android-sdk存放的位置。</p><h3 id="build-gradle-–-gradle仓库"><a href="#build-gradle-–-gradle仓库" class="headerlink" title="build.gradle – gradle仓库"></a>build.gradle – gradle仓库</h3><p>如果不修改这个文件，网上说下载速度很慢，我自己的体验是直接报错，无法下载。<br>将gradle仓库修改为国内的阿里云地址，下载速度嗖嗖的，下面为我的build.gradle文件内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Top-level build file where you can add configuration options common to all sub-projects/modules.</span></span><br><span class="line"></span><br><span class="line">buildscript &#123;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">        def REPOSITORY_URL = <span class="string">'http://maven.aliyun.com/nexus/content/groups/public/'</span></span><br><span class="line">        all &#123; ArtifactRepository repo -&gt;</span><br><span class="line">            <span class="keyword">if</span>(repo <span class="keyword">instanceof</span> MavenArtifactRepository)&#123;</span><br><span class="line">                def url = repo.url.toString()</span><br><span class="line">                <span class="keyword">if</span> (url.startsWith(<span class="string">'https://repo1.maven.org/maven2'</span>) || url.startsWith(<span class="string">'https://jcenter.bintray.com/'</span>)) &#123;</span><br><span class="line">                    remove repo</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url REPOSITORY_URL</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//google()</span></span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">'com.android.tools.build:gradle:2.1.2'</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> Do not place your application dependencies here; they belong</span></span><br><span class="line">        <span class="comment">// in the individual module build.gradle files</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">repositories &#123;</span><br><span class="line">        def REPOSITORY_URL = <span class="string">'http://maven.aliyun.com/nexus/content/groups/public/'</span></span><br><span class="line">        all &#123; ArtifactRepository repo -&gt;</span><br><span class="line">            <span class="keyword">if</span>(repo <span class="keyword">instanceof</span> MavenArtifactRepository)&#123;</span><br><span class="line">                def url = repo.url.toString()</span><br><span class="line">                <span class="keyword">if</span> (url.startsWith(<span class="string">'https://repo1.maven.org/maven2'</span>) || url.startsWith(<span class="string">'https://jcenter.bintray.com/'</span>)) &#123;</span><br><span class="line">                    remove repo</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url REPOSITORY_URL</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//google()</span></span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">clean</span><span class="params">(type: Delete)</span> </span>&#123;</span><br><span class="line">    delete rootProject.buildDir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在下载时出现<code>Could not create plugin of type &#39;AppPlugin&#39;</code>错误，可以先把gradle缓存目录清空，我被这个问题整了两天。</p><h3 id="gradle使用代理"><a href="#gradle使用代理" class="headerlink" title="gradle使用代理"></a>gradle使用代理</h3><p>如果你不想用国内的镜像地址，可以翻墙走代理，方法为修改<code>gradle.properties</code>文件，添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.gradle.jvmargs=-DsocksProxyHost=127.0.0.1 -DsocksProxyPort=1080</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;前言：为了跑通gradle，差点没费死劲，本文记录配置gradle过程中踩过的坑&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;gradle是什么，为什么要配置gradle&quot;&gt;&lt;a href=&quot;#gradle是什么，为什么要配置gradle&quot;
      
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="构建" scheme="http://yoursite.com/tags/%E6%9E%84%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>IP地址与mac地址获取小结</title>
    <link href="http://yoursite.com/2018/11/11/QNX%E5%B9%B3%E5%8F%B0%E8%8E%B7%E5%8F%96ip%E4%B8%8Emac/"/>
    <id>http://yoursite.com/2018/11/11/QNX平台获取ip与mac/</id>
    <published>2018-11-10T19:00:00.000Z</published>
    <updated>2020-05-10T07:08:08.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux平台获取IP地址"><a href="#Linux平台获取IP地址" class="headerlink" title="Linux平台获取IP地址"></a>Linux平台获取IP地址</h2><p>首先是使用<code>ioctl</code>获取IP地址的方法，代码如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getIPAddr</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ipAddrs)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">int</span> interfaceNum = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">buf</span>[16];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ifconf</span> <span class="title">ifc</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifrcopy</span>;</span></span><br><span class="line"><span class="keyword">char</span> ip[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">"socket"</span>);</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ifc.ifc_len = <span class="keyword">sizeof</span>(buf);</span><br><span class="line">ifc.ifc_req = buf;</span><br><span class="line"><span class="keyword">if</span> (!ioctl(fd, SIOCGIFCONF, (<span class="keyword">char</span> *)&amp;ifc)) &#123;</span><br><span class="line">interfaceNum = ifc.ifc_len / <span class="keyword">sizeof</span>(struct ifreq);</span><br><span class="line"><span class="keyword">while</span> (interfaceNum-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">ifrcopy = buf[interfaceNum];</span><br><span class="line"><span class="keyword">if</span> (ioctl(fd, SIOCGIFFLAGS, &amp;ifrcopy)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ioctl: %s [%s:%d]\n"</span>, strerror(errno), __FILE__, __LINE__);</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get the IP of this interface</span></span><br><span class="line"><span class="keyword">if</span> (!ioctl(fd, SIOCGIFADDR, (<span class="keyword">char</span> *)&amp;buf[interfaceNum])) &#123;</span><br><span class="line"><span class="built_in">snprintf</span>(ip, <span class="keyword">sizeof</span>(ip), <span class="string">"%s"</span>, (<span class="keyword">char</span> *)inet_ntoa(((struct sockaddr_in *)&amp;(buf[interfaceNum].ifr_addr))-&gt;sin_addr));</span><br><span class="line">ipAddrs.push_back(<span class="built_in">string</span>(ip));</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ioctl: %s [%s:%d]\n"</span>, strerror(errno), __FILE__, __LINE__);</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ioctl: %s [%s:%d]\n"</span>, strerror(errno), __FILE__, __LINE__);</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; iplist;</span><br><span class="line">getIPAddr(iplist);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"get "</span> &lt;&lt; iplist.size() &lt;&lt; <span class="string">" ip."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ipnum = iplist.size();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ipnum; i++) &#123;</span><br><span class="line"><span class="built_in">string</span> ip = iplist[i];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ip"</span> &lt;&lt; i &lt;&lt; <span class="string">": "</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, ip.c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码通过<code>ioctl</code>获得本机的ip，核心代码为：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">ioctl(fd, SIOCGIFADDR, (<span class="keyword">char</span> *)&amp;buf[interfaceNum]);</span><br></pre></td></tr></table></figure><p>当<code>ioctl</code>第二个参数为<code>SIOCGIFADDR</code>，得到的结果就是ip地址。  </p><h2 id="Linux获得mac地址"><a href="#Linux获得mac地址" class="headerlink" title="Linux获得mac地址"></a>Linux获得mac地址</h2><p>下面是一种最常用的使用<code>ioctl</code>获取mac地址的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>   <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>   <span class="meta-string">&lt;sys/ioctl.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>   <span class="meta-string">&lt;sys/socket.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>   <span class="meta-string">&lt;netinet/in.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>   <span class="meta-string">&lt;net/if.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>   <span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">m_ifreq</span>;</span> </span><br><span class="line">    <span class="keyword">int</span> sock; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: ethname\n "</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>((sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123; </span><br><span class="line">        perror(<span class="string">"socket"</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(m_ifreq.ifr_name,argv[<span class="number">1</span>]); </span><br><span class="line">    <span class="keyword">if</span>(ioctl(sock, SIOCGIFHWADDR, &amp;m_ifreq) &lt; <span class="number">0</span>) &#123; </span><br><span class="line">        perror(<span class="string">"ioctl"</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">"%02x:%02x:%02x:%02x:%02x:%02x\n"</span>, </span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">char</span>)m_ifreq.ifr_hwaddr.sa_data[<span class="number">0</span>], </span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">char</span>)m_ifreq.ifr_hwaddr.sa_data[<span class="number">1</span>], </span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">char</span>)m_ifreq.ifr_hwaddr.sa_data[<span class="number">2</span>], </span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">char</span>)m_ifreq.ifr_hwaddr.sa_data[<span class="number">3</span>], </span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">char</span>)m_ifreq.ifr_hwaddr.sa_data[<span class="number">4</span>], </span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">char</span>)m_ifreq.ifr_hwaddr.sa_data[<span class="number">5</span>]); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获得mac地址的核心代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sock=socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">ioctl(sock, SIOCGIFHWADDR, &amp;m_ifreq);</span><br></pre></td></tr></table></figure><p>获取到的mac地址放在结构体<code>m_ifreq.ifr_hwaddr.sa_data</code>中。</p><h2 id="QNX平台获取mac的方法"><a href="#QNX平台获取mac的方法" class="headerlink" title="QNX平台获取mac的方法"></a>QNX平台获取mac的方法</h2><p>在QNX平台中，<code>net/if.h</code>与linux下不同，<code>ifreq</code>结构体的定义中不存在<code>ifr_hwaddr</code>的成员，我估计<code>ioctl</code>的实现方式也不同，因此上述方法不能使用。</p><p>这时应该转而使用<code>ifaddrs.h</code>中的方法：<code>getifaddrs</code>。示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ifaddrs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netpacket/packet.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/ethernet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if_dl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listmacaddrs</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifaddrs</span> *<span class="title">ifap</span>, *<span class="title">ifaptr</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getifaddrs(&amp;ifap) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(ifaptr = ifap; ifaptr != <span class="literal">NULL</span>; ifaptr = (ifaptr)-&gt;ifa_next) &#123;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></span><br><span class="line">                <span class="keyword">char</span> macp[INET6_ADDRSTRLEN];</span><br><span class="line">                <span class="keyword">if</span> (((ifaptr)-&gt;ifa_addr)-&gt;sa_family == AF_PACKET) &#123;</span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_ll</span> *<span class="title">s</span> = (<span class="title">struct</span> <span class="title">sockaddr_ll</span>*)(<span class="title">ifaptr</span>-&gt;<span class="title">ifa_addr</span>);</span></span><br><span class="line">                    <span class="keyword">int</span> i;</span><br><span class="line">                    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">                        len += <span class="built_in">sprintf</span>(macp+len, <span class="string">"%02X%s"</span>, s-&gt;sll_addr[i], i &lt; <span class="number">5</span> ? <span class="string">":"</span>:<span class="string">""</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%s: %s\n"</span>, (ifaptr)-&gt;ifa_name, macp);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">if</span> (((ifaptr)-&gt;ifa_addr)-&gt;sa_family == AF_LINK) &#123;</span><br><span class="line">                ptr = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)LLADDR((struct sockaddr_dl *)(ifaptr)-&gt;ifa_addr);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s: %02x:%02x:%02x:%02x:%02x:%02x\n"</span>,</span><br><span class="line">                                    (ifaptr)-&gt;ifa_name,</span><br><span class="line">                                    *ptr, *(ptr+<span class="number">1</span>), *(ptr+<span class="number">2</span>), *(ptr+<span class="number">3</span>), *(ptr+<span class="number">4</span>), *(ptr+<span class="number">5</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        freeifaddrs(ifap);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>getifaddrs(&amp;ifap)</code>将mac地址与ip地址同时放到<code>ifap</code>结构体中，该结构体的类型为<code>ifaddrs</code>。</p><p>其核心代码为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ifaddrs</span> *<span class="title">ifap</span>,  *<span class="title">ifaptr</span>;</span></span><br><span class="line">getifaddrs(&amp;ifap);</span><br><span class="line"><span class="keyword">for</span>(ifaptr = ifap; ifaptr != <span class="literal">NULL</span>; ifaptr = (ifaptr)-&gt;ifa_next) &#123;</span><br><span class="line">ptr = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)LLADDR((struct sockaddr_dl *)(ifaptr)-&gt;ifa_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s: %02x:%02x:%02x:%02x:%02x:%02x\n"</span>, (ifaptr)-&gt;ifa_name, *ptr, *(ptr+<span class="number">1</span>), *(ptr+<span class="number">2</span>), *(ptr+<span class="number">3</span>), *(ptr+<span class="number">4</span>), *(ptr+<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ifaddrs::ifa_name</code>为网卡名，<code>ifaddrs::ifa_addr</code>中存放mac地址。</p><p>通过<code>getnameinfo</code>可获得ip地址，ip地址在<code>host</code>中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = getnameinfo(ifa-&gt;ifa_addr, (family == AF_INET)?<span class="keyword">sizeof</span>(struct sockaddr_in):<span class="keyword">sizeof</span>(struct sockaddr_in6), host, NI_MAXHOST, <span class="literal">NULL</span>, <span class="number">0</span>, NUMERICHOST);</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ifaddrs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifaddrs</span> *<span class="title">ifaddr</span>, *<span class="title">ifa</span>;</span></span><br><span class="line">    <span class="keyword">int</span> family, s;</span><br><span class="line">    <span class="keyword">char</span> host[NI_MAXHOST];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (getifaddrs(&amp;ifaddr) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"getifaddrs"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Walk through linked list, maintaining head pointer so we</span></span><br><span class="line"><span class="comment">     *               can free list later */</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (ifa = ifaddr; ifa != <span class="literal">NULL</span>; ifa = ifa-&gt;ifa_next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ifa-&gt;ifa_addr == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line">        family = ifa-&gt;ifa_addr-&gt;sa_family;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* Display interface name and family (including symbolic</span></span><br><span class="line"><span class="comment">         *                   form of the latter for the common families) */</span></span><br><span class="line"> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s  address family: %d%s\n"</span>,</span><br><span class="line">                ifa-&gt;ifa_name, family,</span><br><span class="line">                (family == AF_PACKET) ? <span class="string">" (AF_PACKET)"</span> :</span><br><span class="line">                (family == AF_INET) ?   <span class="string">" (AF_INET)"</span> :</span><br><span class="line">                (family == AF_INET6) ?  <span class="string">" (AF_INET6)"</span> : <span class="string">""</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* For an AF_INET* interface address, display the address */</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (family == AF_INET || family == AF_INET6) &#123;</span><br><span class="line">            s = getnameinfo(ifa-&gt;ifa_addr,</span><br><span class="line">                    (family == AF_INET) ? <span class="keyword">sizeof</span>(struct sockaddr_in) :</span><br><span class="line">                    <span class="keyword">sizeof</span>(struct sockaddr_in6),</span><br><span class="line">                    host, NI_MAXHOST, <span class="literal">NULL</span>, <span class="number">0</span>, NI_NUMERICHOST);</span><br><span class="line">            <span class="keyword">if</span> (s != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"getnameinfo() failed: %s\n"</span>, gai_strerror(s));</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\taddress: &lt;%s&gt;\n"</span>, host);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    freeifaddrs(ifaddr);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>必须要注意的是<code>getifaddrs</code>的调用必须与<code>freeifaddrs</code>成对出现，如果不进行内存释放，会造成内存泄漏</strong></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><em>Linxu的struct ifaddrs与getifaddrs()函数：<a href="https://blog.csdn.net/g457499940/article/details/13630549" target="_blank" rel="noopener">https://blog.csdn.net/g457499940/article/details/13630549</a></em><br><em>怎么得到带有getifaddrs的mac地址？：<a href="https://cloud.tencent.com/developer/ask/148099" target="_blank" rel="noopener">https://cloud.tencent.com/developer/ask/148099</a></em><br><em>Linux下的ioctl()函数详解：<a href="https://www.cnblogs.com/tdyizhen1314/p/4896689.html" target="_blank" rel="noopener">https://www.cnblogs.com/tdyizhen1314/p/4896689.html</a></em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Linux平台获取IP地址&quot;&gt;&lt;a href=&quot;#Linux平台获取IP地址&quot; class=&quot;headerlink&quot; title=&quot;Linux平台获取IP地址&quot;&gt;&lt;/a&gt;Linux平台获取IP地址&lt;/h2&gt;&lt;p&gt;首先是使用&lt;code&gt;ioctl&lt;/code&gt;获取I
      
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="QNX" scheme="http://yoursite.com/tags/QNX/"/>
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>内存泄露检测--mtrace的使用</title>
    <link href="http://yoursite.com/2018/09/30/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%A3%80%E6%B5%8B/"/>
    <id>http://yoursite.com/2018/09/30/内存泄露检测/</id>
    <published>2018-09-30T15:00:00.000Z</published>
    <updated>2020-05-10T07:10:31.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码配置"><a href="#代码配置" class="headerlink" title="代码配置"></a>代码配置</h2><p>首先检测单一文件的内存泄漏。</p><p>有以下程序：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mcheck.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setenv(<span class="string">"MALLOC_TRACE"</span>, <span class="string">"mem.log"</span>, <span class="number">1</span>);</span><br><span class="line">    mtrace();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">0</span> != cnt--) &#123;</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        usleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"over\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中<code>mtrace()</code>依赖于头文件<code>mcheck.h</code>，其只能检测使用glibc的内存分配函数分配的内存，也就是<code>malloc()</code>等内存分配函数，而不支持C++中的<code>new</code>操作符。<br><code>usleep()</code>依赖头文件<code>unistd.h</code>，其休眠1us。</p><p>需要<code>export MALLOC_TRACE=mem.log</code>来指定工作路径，从而指定生成的log。<br>或者调用<code>setenv(&quot;MALLOC_TRACE&quot;, &quot;mem.log&quot;, 1);</code>。依赖于头文件<code>stdlib.h</code>。</p><p>使用如下make文件进行编译，重点在于必须加<code>-g</code>，编译优化选项必须为<code>-O0</code>（或者默认）：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test : test.o</span><br><span class="line">gcc -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line">test.o : test.cpp</span><br><span class="line">gcc -c -O0 <span class="variable">$^</span> -g</span><br></pre></td></tr></table></figure></p><h2 id="查看log"><a href="#查看log" class="headerlink" title="查看log"></a>查看log</h2><p>代码运行后生成log，使用命令<code>mtrace progname logname</code>进行log查看。<br>其中<code>progname</code>为二进制文件名，<code>logname</code>为log的文件名。<br>如果没有内存泄漏会报<code>No memory leaks.</code>。而上述程序的输出结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Memory not freed:</span><br><span class="line">-----------------</span><br><span class="line">           Address     Size     Caller</span><br><span class="line">0x00000000023be6a0      0x8  at /home/zyliu12/Documents/memoryleak/onefile/test.cpp:12</span><br><span class="line">0x00000000023be6c0      0x8  at /home/zyliu12/Documents/memoryleak/onefile/test.cpp:12</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>从而将所有已<code>malloc</code>而未<code>free</code>的内存的<code>malloc</code>处打印出来。</p><h2 id="编译生成库文件"><a href="#编译生成库文件" class="headerlink" title="编译生成库文件"></a>编译生成库文件</h2><p>首先将内存泄露的函数转移到另一个文件<code>fun.cpp</code>中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fun.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">memleak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">0</span> != cnt--) &#123;</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        usleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> *p2 = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">40</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在<code>main.cpp</code>中调用该函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mcheck.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fun.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setenv(<span class="string">"MALLOC_TRACE"</span>, <span class="string">"taoge.log"</span>, <span class="number">1</span>);</span><br><span class="line">    mtrace();</span><br><span class="line">    memleak();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"over\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样<code>mtrace()</code>与内存泄漏的函数不在一个文件中，我们来看看能否检测出内存泄漏的位置。</p><p>一步生成二进制文件的makefile为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TARGET := test</span><br><span class="line">SRC_CXX := fun.cpp main.cpp</span><br><span class="line"></span><br><span class="line">all : clean <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">-@rm -rf *.o *.gch <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span> : <span class="variable">$(SRC_CXX)</span></span><br><span class="line">gcc -o <span class="variable">$@</span> <span class="variable">$^</span> -g</span><br></pre></td></tr></table></figure><p>运行<code>test</code>并使用命令<code>mtrace test taoge.log</code>看到以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Memory not freed:</span><br><span class="line">-----------------</span><br><span class="line">           Address     Size     Caller</span><br><span class="line">0x000000000098e6a0      0x8  at /home/zyliu12/Documents/memoryleak/staticlib/fun.cpp:9</span><br><span class="line">...</span><br><span class="line">0x000000000098f320     0xa0  at /home/zyliu12/Documents/memoryleak/staticlib/fun.cpp:12</span><br></pre></td></tr></table></figure></p><p>此时能够正常判断内存泄露。</p><p>使用以下make文件先将<code>fun.cpp</code>生成为动态库so文件。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TARGET := test</span><br><span class="line">SRC_CXX := main.cpp</span><br><span class="line">SHARED := libfun.so</span><br><span class="line"></span><br><span class="line">all : clean <span class="variable">$(SHARED)</span> <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">-@rm -rf *.o *.gch <span class="variable">$(TARGET)</span> <span class="variable">$(SHARED)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(SHARED)</span> : fun.cpp</span><br><span class="line">gcc -g <span class="variable">$^</span> -fPIC -shared -Wl,-soname,<span class="variable">$(SHARED)</span> -o <span class="variable">$(SHARED)</span> -lc</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span> : <span class="variable">$(SRC_CXX)</span></span><br><span class="line">gcc -o <span class="variable">$@</span> <span class="variable">$^</span> -g -L. -lfun</span><br></pre></td></tr></table></figure><p>在执行二进制文件之前，需要先设置工作路径：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$&#123;pwd&#125;</span>:<span class="variable">$&#123;LD_LIBRARY_PATH&#125;</span></span><br></pre></td></tr></table></figure><p>运行二进制文件生成log，使用命令<code>mtrace test taoge.log</code>看到以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000b466a0    0x400  at 0x7fd589037185</span><br><span class="line">...</span><br><span class="line">0x0000000000b47690      0x8  at 0x7fd58939377a</span><br><span class="line">0x0000000000b476b0      0x8  at 0x7fd58939377a</span><br></pre></td></tr></table></figure></p><p>可以看到只有地址而没有代码行号。</p><h2 id="定位内存泄漏行号"><a href="#定位内存泄漏行号" class="headerlink" title="定位内存泄漏行号"></a>定位内存泄漏行号</h2><p>主要是通过<code>addr2line</code>由地址定位到行号。</p><p>为了得到加载库的地址，首先在代码中添加：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pid=%d\n"</span>, getpid());</span><br></pre></td></tr></table></figure></p><p>这行代码可用于获得程序的pid。在获得程序pid之后，假设pid为7954，进入<code>/proc</code>目录，执行指令<code>cat 7954/maps</code>。其输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">00400000-00401000 r-xp 00000000 08:01 404531                             /home/zyliu12/Documents/memoryleak/staticlib/test</span><br><span class="line">00600000-00601000 r--p 00000000 08:01 404531                             /home/zyliu12/Documents/memoryleak/staticlib/test</span><br><span class="line">00601000-00602000 rw-p 00001000 08:01 404531                             /home/zyliu12/Documents/memoryleak/staticlib/test</span><br><span class="line">017b2000-017d3000 rw-p 00000000 00:00 0                                  [heap]</span><br><span class="line">7fb30a05e000-7fb30a21e000 r-xp 00000000 08:01 660718                     /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">7fb30a21e000-7fb30a41d000 ---p 001c0000 08:01 660718                     /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">7fb30a41d000-7fb30a421000 r--p 001bf000 08:01 660718                     /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">7fb30a421000-7fb30a423000 rw-p 001c3000 08:01 660718                     /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">7fb30a423000-7fb30a427000 rw-p 00000000 00:00 0 </span><br><span class="line">7fb30a427000-7fb30a428000 r-xp 00000000 08:01 404409                     /home/zyliu12/Documents/memoryleak/staticlib/libfun.so</span><br><span class="line">7fb30a428000-7fb30a627000 ---p 00001000 08:01 404409                     /home/zyliu12/Documents/memoryleak/staticlib/libfun.so</span><br><span class="line">7fb30a627000-7fb30a628000 r--p 00000000 08:01 404409                     /home/zyliu12/Documents/memoryleak/staticlib/libfun.so</span><br><span class="line">7fb30a628000-7fb30a629000 rw-p 00001000 08:01 404409                     /home/zyliu12/Documents/memoryleak/staticlib/libfun.so</span><br><span class="line">7fb30a629000-7fb30a64f000 r-xp 00000000 08:01 660690                     /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">7fb30a833000-7fb30a836000 rw-p 00000000 00:00 0 </span><br><span class="line">7fb30a84c000-7fb30a84e000 rw-p 00000000 00:00 0 </span><br><span class="line">7fb30a84e000-7fb30a84f000 r--p 00025000 08:01 660690                     /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">7fb30a84f000-7fb30a850000 rw-p 00026000 08:01 660690                     /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">7fb30a850000-7fb30a851000 rw-p 00000000 00:00 0 </span><br><span class="line">7ffd7c1e6000-7ffd7c207000 rw-p 00000000 00:00 0                          [stack]</span><br><span class="line">7ffd7c23b000-7ffd7c23d000 r--p 00000000 00:00 0                          [vvar]</span><br><span class="line">7ffd7c23d000-7ffd7c23f000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]</span><br></pre></td></tr></table></figure></p><p>可以看到<code>libfun.so</code>的加载地址以<code>7fb30a427000</code>开始。<br>再次查看<code>mtrace test taoge.log</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00000000017b26a0      0x8  at 0x7fb30a42771e</span><br></pre></td></tr></table></figure></p><p><code>0x7fb30a42771e - 0x7fb30a427000</code>可得<code>0x00000000071e</code>，这就是出错代码在<code>libfun.so</code>中的相对位置。<br>执行指令<code>addr2line -e ./libfun.so 0x00000000071e</code>，可得出错代码行号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/zyliu12/Documents/memoryleak/staticlib/fun.cpp:10</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;代码配置&quot;&gt;&lt;a href=&quot;#代码配置&quot; class=&quot;headerlink&quot; title=&quot;代码配置&quot;&gt;&lt;/a&gt;代码配置&lt;/h2&gt;&lt;p&gt;首先检测单一文件的内存泄漏。&lt;/p&gt;
&lt;p&gt;有以下程序：&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;
      
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="内存泄露" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    
  </entry>
  
  <entry>
    <title>Core File的生成和查看</title>
    <link href="http://yoursite.com/2018/09/25/Core%20File%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E6%9F%A5%E7%9C%8B/"/>
    <id>http://yoursite.com/2018/09/25/Core File的生成与查看/</id>
    <published>2018-09-25T15:00:00.000Z</published>
    <updated>2020-05-10T07:06:16.972Z</updated>
    
    <content type="html"><![CDATA[<h2 id="coredump配置"><a href="#coredump配置" class="headerlink" title="coredump配置"></a>coredump配置</h2><h3 id="开启coredump功能"><a href="#开启coredump功能" class="headerlink" title="开启coredump功能"></a>开启coredump功能</h3><p>输入命令<code>ulimit</code>，其输出代表生成的core文件大小的限制，如果输出为0，则说明coredump功能没有开启。</p><p>使用命令<code>ulimit -c unlimited</code>开启coredump功能，并且不限制core文件的大小。</p><p>如果要限制core文件的大小，则将unlimited替换为要限制的core文件的大小，单位为block（KB）。</p><h3 id="Core文件的保存路径"><a href="#Core文件的保存路径" class="headerlink" title="Core文件的保存路径"></a>Core文件的保存路径</h3><p>core文件的生成位置由<code>/proc/sys/kernel/core_pattern</code>中的配置决定。默认情况下，其内容为<code>cor</code>，程序出错时将在工作目录生成名为core的core文件。（此处不确定）<br>可以将配置文件内容改为<code>/home/ubuntu/sdcard/CoreDump/core-%e-%p-%t</code>，则core文件生成在目录/home/ubuntu/sdcard/CoreDump，文件名的格式为core-命令名-pid-时间戳。</p><p>修改配置文件时不能直接用编辑器编辑<code>/proc/sys/kernel/core_pattern</code>。需要先用su命令切换为root用户，然后使用命令编辑文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> /home/coredump/corename &gt; /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure><p>上述命令将core文件生成在/home/coredump/目录下。</p><p>core文件的命名规则：<br>%p - pid<br>%u - uid<br>%g - 当前gid<br>%s - 导致产生core的信号<br>%t - core文件生成的unix时间<br>%h - 主机名<br>%e - 命令名<br>若要将core文件生成位置恢复为默认，使用以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> core &gt; /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure><h2 id="core文件的读取"><a href="#core文件的读取" class="headerlink" title="core文件的读取"></a>core文件的读取</h2><p>有了core文件之后，可以使用GDB来进行调试。</p><p>调试方式为使用命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb program core</span><br></pre></td></tr></table></figure></p><p>其中program为生成core文件的对应程序名，core为core文件名。<br>例如，现有test.c内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = *p;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> func(p);</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">使用gcc编译生成可执行文件test：</span><br><span class="line">```sh</span><br><span class="line">gcc –o test test.c –g</span><br></pre></td></tr></table></figure><p>运行test，生成core文件，以默认设置为例，则core生成在当前目录。<br>使用命令<code>gdb test core</code>，结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Core was generated by &apos;./test&apos;.</span><br><span class="line">Program terminated with signal 11, Segmentation fault.</span><br><span class="line">#0  0x080483cd in func (p=0x0) at test.c:5</span><br><span class="line">5       int y = *p;</span><br><span class="line"></span><br><span class="line">(gdb)  where</span><br><span class="line">#0  0x080483cd in func (p=0x0) at core_demo.c:5</span><br><span class="line">#1  0x080483ef in main () at core_demo.c:12</span><br><span class="line">(gdb) info frame</span><br><span class="line">Stack level 0, frame at 0xffd590a4:</span><br><span class="line"> eip = 0x80483cd in func (test.c:5); saved eip 0x80483ef</span><br><span class="line"> called by frame at 0xffd590c0</span><br><span class="line"> source language c.</span><br><span class="line"> Arglist at 0xffd5909c, args: p=0x0</span><br><span class="line"> Locals at 0xffd5909c, Previous frame&apos;s sp is 0xffd590a4</span><br><span class="line"> Saved registers:</span><br><span class="line">  ebp at 0xffd5909c, eip at 0xffd590a0</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>可以看到程序错误的原因在最后两行显示。可以使用where命令再次显示程序崩溃原因。</p><p>参考资料：<br><a href="http://www.cnblogs.com/hazir/p/linxu_core_dump.html" target="_blank" rel="noopener">http://www.cnblogs.com/hazir/p/linxu_core_dump.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;coredump配置&quot;&gt;&lt;a href=&quot;#coredump配置&quot; class=&quot;headerlink&quot; title=&quot;coredump配置&quot;&gt;&lt;/a&gt;coredump配置&lt;/h2&gt;&lt;h3 id=&quot;开启coredump功能&quot;&gt;&lt;a href=&quot;#开启coredum
      
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="GDB" scheme="http://yoursite.com/tags/GDB/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>头文件包含以及库文件包含</title>
    <link href="http://yoursite.com/2018/08/31/%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%BB%A5%E5%8F%8A%E5%BA%93%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    <id>http://yoursite.com/2018/08/31/头文件包含以及库文件包含/</id>
    <published>2018-08-31T09:53:00.000Z</published>
    <updated>2020-05-10T07:13:25.810Z</updated>
    
    <content type="html"><![CDATA[<h2 id="防止重复包含头文件"><a href="#防止重复包含头文件" class="headerlink" title="防止重复包含头文件"></a>防止重复包含头文件</h2><p>在头文件中包含头文件常导致重复定义的问题。Windows平台上常常使用<code>#pragma once</code>的方式来防止重复定义，但在跨平台项目上这么做就不太适用了。<br>因此我们常常使用预定义的方式来防止重复定义的问题。之前我只是知道有这么回事，但并不知道是如何实现的，下面对其进行总结。<br>以某个头文件<code>&quot;header.h&quot;</code>为例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">ifndef</span> __HEADER_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HEADER_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *header.h  body</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p>如果该头文件已被包含，那么头文件中的定义不会被重复定义。</p><h2 id="库文件的包含"><a href="#库文件的包含" class="headerlink" title="库文件的包含"></a>库文件的包含</h2><p>在Windows中，有两种方式可以包含库文件。</p><p>一种是在代码中添加：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"libname.lib"</span>)</span></span><br></pre></td></tr></table></figure></p><p>另一种是在<code>项目 - 属性 - 配置属性 - 链接器 - 输入 - 附加依赖项</code>中添加库文件。</p><p>如果上述两种方式只添加了文件名而没有路径，则需要在<code>项目 - 属性 - 配置属性 - 链接器 - 常规 - 附加库目录</code>中添加库文件的路径。</p><p>在Linux操作系统中，使用makefile指定包含的库文件。</p><p>比如需要包含GNUC库文件<code>librt.so</code>，在make时指定<code>-lrt</code>即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;防止重复包含头文件&quot;&gt;&lt;a href=&quot;#防止重复包含头文件&quot; class=&quot;headerlink&quot; title=&quot;防止重复包含头文件&quot;&gt;&lt;/a&gt;防止重复包含头文件&lt;/h2&gt;&lt;p&gt;在头文件中包含头文件常导致重复定义的问题。Windows平台上常常使用&lt;code&gt;#
      
    
    </summary>
    
      <category term="记录" scheme="http://yoursite.com/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>从VS转移到VScode（由未找到预定义引出的问题）</title>
    <link href="http://yoursite.com/2018/08/24/%E4%BB%8EVS%E8%BD%AC%E7%A7%BB%E5%88%B0VScode%EF%BC%88%E7%94%B1%E6%9C%AA%E6%89%BE%E5%88%B0%E9%A2%84%E5%AE%9A%E4%B9%89%E5%BC%95%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%89/"/>
    <id>http://yoursite.com/2018/08/24/从VS转移到VScode（由未找到预定义引出的问题）/</id>
    <published>2018-08-23T16:40:00.000Z</published>
    <updated>2020-05-10T07:09:55.546Z</updated>
    
    <content type="html"><![CDATA[<h2 id="作为代码编辑器的VScode"><a href="#作为代码编辑器的VScode" class="headerlink" title="作为代码编辑器的VScode"></a>作为代码编辑器的VScode</h2><h3 id="预定义"><a href="#预定义" class="headerlink" title="预定义"></a>预定义</h3><p>今天看到代码中有一处：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined FF_LOG_ZZSR</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../VACommon/log/sr_log.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined FF_LOG_ZZHX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../VACommon/log/HX_log.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p>搜索编整个工程却没有找到<code>FF_LOG_ZZHX</code>，然而其下方的<code>#include</code>的代码却生效了，因此感到很疑惑。</p><p>实际上是在<code>属性 - 配置属性 - C/C++ - 预处理器定义</code>中进行了预处理定义，这样在所有代码中都有了<code>FF_LOG_ZZHX</code>的预定义。</p><p>当使用VSCode打开源文件时，需要在<code>$WorkSpace$\.vscode\c_cpp_properties.json</code>中的<code>defines</code>项添加预定义。</p><h3 id="包含文件"><a href="#包含文件" class="headerlink" title="包含文件"></a>包含文件</h3><p>在添加了预定义之后，发现代码仍有问题，<code>DEBUG_TRACE_ERROR</code>等依赖于<code>VACommon/log/HX_log.h</code>的预定义仍不起作用。试验后发现还需要添加包含路径。最终的<code>c_cpp_properties.json</code>如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Win32"</span>,</span><br><span class="line">            <span class="attr">"includePath"</span>: [</span><br><span class="line">                <span class="string">"$&#123;workspaceFolder&#125;/**"</span>,</span><br><span class="line">                <span class="string">"./../VACommon/**"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"defines"</span>: [</span><br><span class="line">                <span class="string">"_DEBUG"</span>,</span><br><span class="line">                <span class="string">"UNICODE"</span>,</span><br><span class="line">                <span class="string">"_UNICODE"</span>,</span><br><span class="line">                <span class="string">"ZZ_DLL_EXPORTS"</span>,</span><br><span class="line">                <span class="string">"WIN32"</span>,</span><br><span class="line">                <span class="string">"ZZ_EMNLU20_DEFINED"</span>,</span><br><span class="line">                <span class="string">"FF_LOG_ZZHX"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"intelliSenseMode"</span>: <span class="string">"msvc-x64"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"version"</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编译配置"><a href="#编译配置" class="headerlink" title="编译配置"></a>编译配置</h2><p>此外还有很多编译相关的配置，以及makefile的配置，将在后面进行补充。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;作为代码编辑器的VScode&quot;&gt;&lt;a href=&quot;#作为代码编辑器的VScode&quot; class=&quot;headerlink&quot; title=&quot;作为代码编辑器的VScode&quot;&gt;&lt;/a&gt;作为代码编辑器的VScode&lt;/h2&gt;&lt;h3 id=&quot;预定义&quot;&gt;&lt;a href=&quot;#预定
      
    
    </summary>
    
      <category term="记录" scheme="http://yoursite.com/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="编译" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91/"/>
    
      <category term="编辑器" scheme="http://yoursite.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Makefile学习（三）</title>
    <link href="http://yoursite.com/2018/08/19/makefile(3)/"/>
    <id>http://yoursite.com/2018/08/19/makefile(3)/</id>
    <published>2018-08-19T15:00:00.000Z</published>
    <updated>2020-05-10T07:07:30.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="8-make的运行"><a href="#8-make的运行" class="headerlink" title="8 make的运行"></a>8 make的运行</h2><p>一般来说，最简单的就是直接在命令行下输入make命令，make命令会找当前目录的makefile来执行，一切都是自动的。但也有时你也许只想让make重编译某些文件，而不是整个工程，而又有的时候你有几套编译规则，你想在不同的时候使用不同的编译规则，等等。本章节就是讲述如何使用make命令的。</p><h3 id="8-1-make的退出码"><a href="#8-1-make的退出码" class="headerlink" title="8.1 make的退出码"></a>8.1 make的退出码</h3><p>make命令执行后有三个退出码：</p><ul><li>0 —— 表示成功执行。</li><li>1 —— 如果make运行时出现任何错误，其返回1。</li><li>2 —— 如果你使用了make的“-q”选项，并且make使得一些目标不需要更新，那么返回2。</li></ul><h3 id="8-2-指定Makefile"><a href="#8-2-指定Makefile" class="headerlink" title="8.2 指定Makefile"></a>8.2 指定Makefile</h3><p>GNU make找寻默认的Makefile的规则是在当前目录下依次找三个文件——“GNUmakefile”、“makefile”和“Makefile”。其按顺序找这三个文件，一旦找到，就开始读取这个文件并执行。</p><p>我们也可以给make命令指定一个特殊名字的Makefile。要达到这个功能，我们要使用make的<code>-f</code>或是<code>--file</code>参数（<code>--makefile</code>参数也行）。例如，我们有个makefile的名字是<code>hchen.mk</code>，那么，我们可以这样来让make来执行这个文件：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make –f hchen.mk</span><br></pre></td></tr></table></figure></p><p>如果在make的命令行，不只一次地使用了“-f”参数，那么，所有指定的makefile将会被连在一起传递给make执行。</p><h3 id="8-3-指定目标"><a href="#8-3-指定目标" class="headerlink" title="8.3 指定目标"></a>8.3 指定目标</h3><p>只需增加目标名字即可将这个目标指定为终极目标。什么也不加的话make会将第一个目标作为终极目标。</p><p>任何在makefile中的目标都可以被指定成终极目标，但是除了以“-”打头，或是包含了“=”的目标，因为有这些字符的目标，会被解析成命令行参数或是变量。甚至没有被我们明确写出来的目标也可以成为make的终极目标，也就是说，只要make可以找到其隐含规则推导规则，那么这个隐含目标同样可以被指定成终极目标。</p><p>有一个make的环境变量叫<code>MAKECMDGOALS</code>，这个变量中会存放你所指定的终极目标的列表，如果在命令行上，你没有指定目标，那么，这个变量是空值。这个变量可以让你使用在一些比较特殊的情形下。比如下面的例子：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sources = foo.c bar.c</span><br><span class="line"><span class="keyword">ifneq</span> ( <span class="variable">$(MAKECMDGOALS)</span>,clean)</span><br><span class="line"><span class="keyword">include</span> $(sources:.c=.d)</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure></p><p>基于上面的这个例子，只要我们输入的命令不是<code>make clean</code>，那么makefile会自动包含<code>foo.d</code>和<code>bar.d</code>这两个makefile。</p><p>即然make可以指定所有makefile中的目标，那么也包括“伪目标”，于是我们可以根据这种性质来让我们的makefile根据指定的不同的目标来完成不同的事。在Unix世界中，软件发布时，特别是GNU这种开源软件的发布时，其makefile都包含了编译、安装、打包等功能。我们可以参照这种规则来书写我们的makefile中的目标。</p><ul><li><p><code>all</code><br>这个伪目标是所有目标的目标，其功能一般是编译所有的目标。</p></li><li><p><code>clean</code><br>这个伪目标功能是删除所有被make创建的文件。</p></li><li><p><code>install</code><br>这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。</p></li><li><p><code>print</code><br>这个伪目标的功能是例出改变过的源文件。</p></li><li><p><code>tar</code><br>这个伪目标功能是把源程序打包备份。也就是一个tar文件。</p></li><li><p><code>dist</code><br>这个伪目标功能是创建一个压缩文件，一般是把tar文件压成Z文件。或是gz文件。</p></li><li><p><code>TAGS</code><br>这个伪目标功能是更新所有的目标，以备完整地重编译使用。</p></li><li><p><code>check</code>和<code>test</code><br>这两个伪目标一般用来测试makefile的流程。</p></li></ul><h3 id="8-4-make的参数"><a href="#8-4-make的参数" class="headerlink" title="8.4 make的参数"></a>8.4 make的参数</h3><p>下面列举了所有GNU make 3.80版的参数定义。其它版本和产商的make大同小异，不过其它产商的make的具体参数还是请参考各自的产品文档。</p><ul><li><p><code>-b</code>/<code>-m</code><br>这两个参数的作用是忽略和其它版本make的兼容性。</p></li><li><p><code>-B</code>/<code>--always-make</code><br>认为所有的目标都需要更新（重编译）。</p></li><li><p><code>-C &lt;dir&gt;</code>/<code>--directory=&lt;dir&gt;</code><br>指定读取makefile的目录。如果有多个<code>-C</code>参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：<code>make –C ~hchen/test –C prog</code>等价于<code>make –C ~hchen/test/prog</code>。</p></li></ul><p><code>—debug[=&lt;options&gt;]</code><br>输出make的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。下面是<code>&lt;options&gt;</code>的取值：<br>    a —— 也就是all，输出所有的调试信息。（会非常的多）<br>    b —— 也就是basic，只输出简单的调试信息。即输出不需要重编译的目标。<br>    v —— 也就是verbose，在b选项的级别之上。输出的信息包括哪个makefile被解析，不需要被重编译的依赖文件（或是依赖目标）等。<br>    i —— 也就是implicit，输出所以的隐含规则。<br>    j —— 也就是jobs，输出执行规则中命令的详细信息，如命令的PID、返回码等。<br>    m —— 也就是makefile，输出make读取makefile，更新makefile，执行makefile的信息。</p><ul><li><p><code>-d</code><br>相当于<code>--debug=a</code>。</p></li><li><p><code>-e</code>/<code>--environment-overrides</code><br>指明环境变量的值覆盖makefile中定义的变量的值。</p></li><li><p><code>-f &lt;file&gt;</code>/<code>--file &lt;file&gt;</code>/<code>--makefile &lt;file&gt;</code><br>指定需要执行的makefile。</p></li><li><p><code>-h</code>/<code>--help</code><br>显示帮助信息。</p></li><li><p><code>-i</code>/<code>--ignore-errors</code><br>在执行时忽略所有的错误。</p></li><li><p><code>-I &lt;dir&gt;</code>/<code>--include-dir &lt;dir&gt;</code><br>指定一个被包含makefile的搜索目标。可以使用多个<code>-I</code>参数来指定多个目录。</p></li><li><p><code>-j [&lt;jobsnum&gt;]</code>/<code>--jobs[=&lt;jobsnum&gt;]</code><br>指同时运行命令的个数。如果没有这个参数，make运行命令时能运行多少就运行多少。如果有一个以上的<code>-j</code>参数，那么仅最后一个<code>-j</code>才是有效的。（注意这个参数在MS-DOS中是无用的）</p></li><li><p><code>-k</code>/<code>--keep-going</code><br>出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了。</p></li><li><p><code>-l &lt;load&gt;</code>/<code>--load-average[=&lt;load]</code>/<code>—max-load[=&lt;load&gt;]</code><br>指定make运行命令的负载。</p></li><li><p><code>-n</code>/<code>--just-print</code>/<code>--dry-run</code>/<code>--recon</code><br>仅输出执行过程中的命令序列，但并不执行。</p></li><li><p><code>-o &lt;file&gt;</code>/<code>--old-file &lt;file&gt;</code>/<code>--assume-old &lt;file&gt;</code><br>不重新生成的指定的<code>&lt;file&gt;</code>，即使这个目标的依赖文件新于它。</p></li><li><p><code>-p</code>/<code>--print-data-base</code><br>输出makefile中的所有数据，包括所有的规则和变量。这个参数会让一个简单的makefile都会输出一堆信息。如果你只是想输出信息而不想执行makefile，你可以使用<code>make -qp</code>命令。如果你想查看执行makefile前的预设变量和规则，你可以使用<code>make –p –f /dev/null</code>。这个参数输出的信息会包含着你的makefile文件的文件名和行号，所以，用这个参数来调试你的makefile会是很有用的，特别是当你的环境变量很复杂的时候。</p></li><li><p><code>-q</code>/<code>--question</code><br>不运行命令，也不输出。仅仅是检查所指定的目标是否需要更新。如果是0则说明要更新，如果是2则说明有错误发生。</p></li><li><p><code>-r</code>/<code>--no-builtin-rules</code><br>禁止make使用任何隐含规则。</p></li><li><p><code>-R</code>/<code>--no-builtin-variabes</code><br>禁止make使用任何作用于变量上的隐含规则。</p></li><li><p><code>-s</code>/<code>--silent</code>/<code>--quiet</code><br>在命令运行时不输出命令的输出。</p></li><li><p><code>-S</code>/<code>--no-keep-going</code>/<code>--stop</code><br>取消<code>-k</code>选项的作用。因为有些时候，make的选项是从环境变量<code>MAKEFLAGS</code>中继承下来的。所以你可以在命令行中使用这个参数来让环境变量中的<code>-k</code>选项失效。</p></li><li><p><code>-t</code>/<code>--touch</code><br>相当于UNIX的touch命令，只是把目标的修改日期变成最新的，也就是阻止生成目标的命令运行。</p></li><li><p><code>-v</code>/<code>--version</code><br>输出make程序的版本、版权等关于make的信息。</p></li><li><p><code>-w</code>/<code>--print-directory</code><br>输出运行makefile之前和之后的信息。这个参数对于跟踪嵌套式调用make时很有用。</p></li><li><p><code>--no-print-directory</code><br>禁止<code>-w</code>选项。</p></li><li><p><code>-W &lt;file&gt;</code>/<code>--what-if=&lt;file&gt;</code>/<code>--new-file=&lt;file&gt;</code>/<code>--assume-file=&lt;file&gt;</code><br>假定目标<code>&lt;file&gt;</code>需要更新，如果和<code>-n</code>选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有<code>-n</code>那么就像运行UNIX的<code>touch</code>命令一样，使得<code>&lt;file&gt;</code>的修改时间为当前时间。</p></li><li><p><code>--warn-undefined-variables</code><br>只要make发现有未定义的变量，那么就输出警告信息。</p></li></ul><hr><h2 id="9-隐含规则"><a href="#9-隐含规则" class="headerlink" title="9 隐含规则"></a>9 隐含规则</h2><p>在我们使用Makefile时，有一些我们会经常使用，而且使用频率非常高的东西，比如，我们编译C/C++的源程序为中间目标文件（Unix下是[.o]文件，Windows下是[.obj]文件）。本章讲述的就是一些在Makefile中的“隐含的”，早先约定了的，不需要我们再写出来的规则。</p><p>“隐含规则”也就是一种惯例，make会按照这种“惯例”心照不喧地来运行，那怕我们的Makefile中没有书写这样的规则。例如，把[.c]文件编译成[.o]文件这一规则，你根本就不用写出来，make会自动推导出这种规则，并生成我们需要的[.o]文件。</p><p>“隐含规则”会使用一些我们系统变量，我们可以改变这些系统变量的值来定制隐含规则的运行时的参数。如系统变量“CFLAGS”可以控制编译时的编译器参数。</p><p>我们还可以通过“模式规则”的方式写下自己的隐含规则。用“后缀规则”来定义隐含规则会有许多的限制。使用“模式规则”会更回得智能和清楚，但“后缀规则”可以用来保证我们Makefile的兼容性。<br>我们了解了“隐含规则”，可以让其为我们更好的服务，也会让我们知道一些“约定俗成”了的东西，而不至于使得我们在运行Makefile时出现一些我们觉得莫名其妙的东西。当然，任何事物都是矛盾的，水能载舟，亦可覆舟，所以，有时候“隐含规则”也会给我们造成不小的麻烦。只有了解了它，我们才能更好地使用它。</p><h3 id="9-1-使用隐含规则"><a href="#9-1-使用隐含规则" class="headerlink" title="9.1 使用隐含规则"></a>9.1 使用隐含规则</h3><p>如果要使用隐含规则生成你需要的目标，你所需要做的就是不要写出这个目标的规则，而是让make自动推到生成这个目标的规则。<br>如果make可以自动推导生成这个目标的规则和命令，那么这个行为就是隐含规则的自动推导。</p><p>例如：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo : foo.o bar.o</span><br><span class="line">    cc –o foo foo.o bar.o <span class="variable">$(CFLAGS)</span> <span class="variable">$(LDFLAGS)</span></span><br></pre></td></tr></table></figure></p><p>一个makefile中只包含以上内容，并没有指出<code>foo.o</code>与<code>bar.o</code>是怎么生成的。make的“隐含规则”功能会自动为我们自动去推导这两个目标的依赖目标和生成命令。<br>make会在自己的“隐含规则”库中寻找可以用的规则，如果找到，那么就会使用。如果找不到，那么就会报错。在上面的例子中，make调用的隐含规则是：把[.o]的目标的依赖文件置成[.c]，并使用C的编译命令<code>cc –c $(CFLAGS) [.c]</code>来生成[.o]的目标。也就是说，我们完全没有必要写下下面的两条规则：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo.o : foo.c</span><br><span class="line">    cc –c foo.c <span class="variable">$(CFLAGS)</span></span><br><span class="line">bar.o : bar.c</span><br><span class="line">    cc –c bar.c <span class="variable">$(CFLAGS)</span></span><br></pre></td></tr></table></figure></p><p>当然，如果我们为[.o]文件书写了自己的规则，那么make就不会自动推导并调用隐含规则，它会按照我们写好的规则忠实地执行。</p><p>在make的“隐含规则库”中，每一条隐含规则都在库中有其顺序，越靠前的则是越被经常使用的，所以，这会导致我们有些时候即使我们显示地指定了目标依赖，make也不会管。如下面这条规则（没有命令）：</p><pre><code>foo.o : foo.p</code></pre><p>依赖文件<code>foo.p</code>（Pascal程序的源文件）有可能变得没有意义。如果目录下存在了<code>foo.c</code>文件，那么我们的隐含规则一样会生效，并会通过<code>foo.c</code>调用C的编译器生成foo.o文件。因为，在隐含规则中，Pascal的规则出现在C的规则之后，所以，make找到可以生成foo.o的C的规则就不再寻找下一条规则了。如果你确实不希望任何隐含规则推导，那么，你就不要只写出“依赖规则”，而不写命令。</p><h3 id="9-2-隐含规则一览"><a href="#9-2-隐含规则一览" class="headerlink" title="9.2 隐含规则一览"></a>9.2 隐含规则一览</h3><p>以下为make内建的隐含规则，如果我们不明确地写下规则，那么，make就会在这些规则中寻找所需要规则和命令。<br>可以使用make的参数<code>-r</code>或<code>--no-builtin-rules</code>选项来取消所有的预设置的隐含规则。<br>即使是我们指定了<code>-r</code>参数，某些隐含规则还是会生效，因为有许多的隐含规则都是使用了“后缀规则”来定义的，所以，只要隐含规则中有“后缀列表”（也就一系统定义在目标.SUFFIXES的依赖目标），那么隐含规则就会生效。默认的后缀列表是：.out, .a, .ln, .o, .c, .cc, .C, .p, .f, .F, .r, .y, .l, .s, .S, .mod, .sym, .def, .h, .info, .dvi, .tex, .texinfo, .texi, .txinfo, .w, .ch .web, .sh, .elc, .el。</p><ol><li><p>编译C程序的隐含规则。<br><code>&lt;n&gt;.o</code>的目标的依赖目标会自动推导为<code>&lt;n&gt;.c</code>，并且其生成命令是<code>$(CC) –c $(CPPFLAGS) $(CFLAGS)</code></p></li><li><p>编译C++程序的隐含规则。<br><code>&lt;n&gt;.o</code>的目标的依赖目标会自动推导为<code>&lt;n&gt;.cc</code>或是<code>&lt;n&gt;.C</code>，并且其生成命令是<code>$(CXX) –c $(CPPFLAGS) $(CFLAGS)</code>。（建议使用<code>.cc</code>作为C++源文件的后缀，而不是<code>.C</code>）</p></li><li><p>编译Pascal程序的隐含规则。<br><code>&lt;n&gt;.o</code>的目标的依赖目标会自动推导为<code>&lt;n&gt;.p</code>，并且其生成命令是<code>$(PC) –c  $(PFLAGS)</code>。</p></li><li><p>编译Fortran/Ratfor程序的隐含规则。<br><code>&lt;n&gt;.o</code>的目标的依赖目标会自动推导为<code>&lt;n&gt;.r</code>或<code>&lt;n&gt;.F</code>或<code>&lt;n&gt;.f</code>，并且其生成命令是:<br> <code>.f</code>  <code>$(FC) –c  $(FFLAGS)</code><br> <code>.F</code>  <code>$(FC) –c  $(FFLAGS) $(CPPFLAGS)</code><br> <code>.f</code>  <code>$(FC) –c  $(FFLAGS) $(RFLAGS)</code></p></li><li><p>预处理Fortran/Ratfor程序的隐含规则。<br><code>&lt;n&gt;.f</code>的目标的依赖目标会自动推导为<code>&lt;n&gt;.r</code>或<code>&lt;n&gt;.F</code>。这个规则只是转换Ratfor或有预处理的Fortran程序到一个标准的Fortran程序。其使用的命令是：<br> <code>.F</code>  <code>$(FC) –F $(CPPFLAGS) $(FFLAGS)</code><br> <code>.r</code>  <code>$(FC) –F $(FFLAGS) $(RFLAGS)</code></p></li><li><p>编译Modula-2程序的隐含规则。<br><code>&lt;n&gt;.sym</code>的目标的依赖目标会自动推导为<code>&lt;n&gt;.def</code>，并且其生成命令是：<code>$(M2C) $(M2FLAGS) $(DEFFLAGS)</code>。<br><code>&lt;n.o&gt;</code>的目标的依赖目标会自动推导为<code>&lt;n&gt;.mod</code>，并且其生成命令是：<code>$(M2C) $(M2FLAGS) $(MODFLAGS)</code>。</p></li><li><p>汇编和汇编预处理的隐含规则。<br><code>&lt;n&gt;.o</code>的目标的依赖目标会自动推导为<code>&lt;n&gt;.s</code>，默认使用编译品<code>as</code>，并且其生成命令是：<code>$(AS) $(ASFLAGS)</code>。<code>&lt;n&gt;.s</code> 的目标的依赖目标会自动推导为<code>&lt;n&gt;.S</code>，默认使用C预编译器<code>cpp</code>，并且其生成命令是：<code>$(AS) $(ASFLAGS)</code>。</p></li><li><p>链接Object文件的隐含规则。<br><code>&lt;n&gt;</code>目标依赖于<code>&lt;n&gt;.o</code>，通过运行C的编译器来运行链接程序生成（一般是<code>ld</code>），其生成命令是：<code>$(CC) $(LDFLAGS) &lt;n&gt;.o $(LOADLIBES) $(LDLIBS)</code>。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则：<code>x : y.o z.o</code>。<br>并且<code>x.c</code>、<code>y.c</code>和<code>z.c</code>都存在时，隐含规则将执行如下命令：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cc -c x.c -o x.o</span><br><span class="line">cc -c y.c -o y.o</span><br><span class="line">cc -c z.c -o z.o</span><br><span class="line">cc x.o y.o z.o -o x</span><br><span class="line">rm -f x.o</span><br><span class="line">rm -f y.o</span><br><span class="line">rm -f z.o</span><br></pre></td></tr></table></figure><p>如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。</p></li><li><p>Yacc C程序时的隐含规则。<br><code>&lt;n&gt;.c</code>的依赖文件被自动推导为<code>n.y</code>（Yacc生成的文件），其生成命令是：<code>$(YACC) $(YFALGS)</code>。（<code>Yacc</code>是一个语法分析器，关于其细节请查看相关资料）</p></li><li><p>Lex C程序时的隐含规则。<br><code>&lt;n&gt;.c</code>的依赖文件被自动推导为<code>n.l</code>（Lex生成的文件），其生成命令是：<code>$(LEX) $(LFALGS)</code>。（关于<code>Lex</code>的细节请查看相关资料）</p></li><li><p>Lex Ratfor程序时的隐含规则。<br><code>&lt;n&gt;.r</code>的依赖文件被自动推导为<code>n.l</code>（Lex生成的文件），其生成命令是：<code>$(LEX) $(LFALGS)</code>。</p></li><li><p>从C程序、Yacc文件或Lex文件创建Lint库的隐含规则。<br><code>&lt;n&gt;.ln</code> （lint生成的文件）的依赖文件被自动推导为<code>n.c</code>，其生成命令是：<code>$(LINT) $(LINTFALGS) $(CPPFLAGS) -i</code>。对于<code>&lt;n&gt;.y</code>和<code>&lt;n&gt;.l</code>也是同样的规则。</p></li></ol><h3 id="9-3-隐含规则使用的变量"><a href="#9-3-隐含规则使用的变量" class="headerlink" title="9.3 隐含规则使用的变量"></a>9.3 隐含规则使用的变量</h3><p>在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以在你的makefile中改变这些变量的值，或是在make的命令行中传入这些值，或是在你的环境变量中设置这些值，无论怎么样，只要设置了这些特定的变量，那么其就会对隐含规则起作用。当然，你也可以利用make的“-R”或“–no–builtin-variables”参数来取消你所定义的变量对隐含规则的作用。</p><p>例如，第一条隐含规则——编译C程序的隐含规则的命令是<code>$(CC) –c $(CFLAGS) $(CPPFLAGS)</code>。Make默认的编译命令是<code>cc</code>，如果你把变量<code>$(CC)</code>重定义成<code>gcc</code>，把变量<code>$(CFLAGS)</code>重定义成<code>-g</code>，那么，隐含规则中的命令全部会以<code>gcc –c -g $(CPPFLAGS)</code>的样子来执行了。</p><p>我们可以把隐含规则中使用的变量分成两种：一种是命令相关的，如<code>CC</code>；一种是参数相的关，如<code>CFLAGS</code>。下面是所有隐含规则中会用到的变量：</p><h4 id="关于命令的变量"><a href="#关于命令的变量" class="headerlink" title="关于命令的变量"></a>关于命令的变量</h4><ul><li><p><code>AR</code><br>  函数库打包程序。默认命令是<code>ar</code>。 </p></li><li><p><code>AS</code><br>  汇编语言编译程序。默认命令是<code>as</code>。</p></li><li><p><code>CC</code><br>  C语言编译程序。默认命令是<code>cc</code>。</p></li><li><p><code>CXX</code><br>  C++语言编译程序。默认命令是<code>g++</code>。</p></li><li><p><code>CO</code><br>  从 RCS文件中扩展文件程序。默认命令是<code>co</code>。</p></li><li><p><code>CPP</code><br>  C程序的预处理器（输出是标准输出设备）。默认命令是<code>$(CC) –E</code>。</p></li><li><p><code>FC</code><br>  Fortran 和 Ratfor 的编译器和预处理程序。默认命令是<code>f77</code>。</p></li><li><p><code>GET</code><br>  从SCCS文件中扩展文件的程序。默认命令是<code>get</code>。 </p></li><li><p><code>LEX</code><br>  Lex方法分析器程序（针对于C或Ratfor）。默认命令是<code>lex</code>。</p></li><li><p><code>PC</code><br>  Pascal语言编译程序。默认命令是<code>pc</code>。</p></li><li><p><code>YACC</code><br>  Yacc文法分析器（针对于C程序）。默认命令是<code>yacc</code>。</p></li><li><p><code>YACCR</code><br>  Yacc文法分析器（针对于Ratfor程序）。默认命令是<code>yacc –r</code>。</p></li><li><p><code>MAKEINFO</code><br>  转换Texinfo源文件（.texi）到Info文件程序。默认命令是<code>makeinfo</code>。</p></li><li><p><code>TEX</code><br>  从TeX源文件创建TeX DVI文件的程序。默认命令是<code>tex</code>。</p></li><li><p><code>TEXI2DVI</code><br>  从Texinfo源文件创建军TeX DVI 文件的程序。默认命令是<code>texi2dvi</code>。</p></li><li><p><code>WEAVE</code><br>  转换Web到TeX的程序。默认命令是<code>weave</code>。</p></li><li><p><code>CWEAVE</code><br>  转换C Web到TeX的程序。默认命令是<code>cweave</code>。</p></li><li><p><code>TANGLE</code><br>  转换Web到Pascal语言的程序。默认命令是<code>tangle</code>。</p></li><li><p><code>CTANGLE</code><br>  转换C Web到C。默认命令是<code>ctangle</code>。</p></li><li><p><code>RM</code><br>  删除文件命令。默认命令是<code>rm –f</code>。</p></li></ul><h4 id="关于参数的变量"><a href="#关于参数的变量" class="headerlink" title="关于参数的变量"></a>关于参数的变量</h4><ul><li><p><code>ARFLAGS</code><br>  函数库打包程序AR命令的参数。默认值是<code>rv</code>。</p></li><li><p><code>ASFLAGS</code><br>  汇编语言编译器参数。（当明显地调用<code>.s</code>或<code>.S</code>文件时）。 </p></li><li><p><code>CFLAGS</code><br>  C语言编译器参数。</p></li><li><p><code>CXXFLAGS</code><br>  C++语言编译器参数。</p></li><li><p><code>COFLAGS</code><br>  RCS命令参数。 </p></li><li><p><code>CPPFLAGS</code><br>  C预处理器参数。（C++和Fortran编译器也会用到）。</p></li><li><p><code>FFLAGS</code><br>  Fortran语言编译器参数。</p></li><li><p><code>GFLAGS</code><br>  SCCS “get”程序参数。</p></li><li><p><code>LDFLAGS</code><br>  链接器参数。（如：<code>ld</code>）</p></li><li><p><code>LFLAGS</code><br>  Lex文法分析器参数。</p></li><li><p><code>PFLAGS</code><br>  Pascal语言编译器参数。</p></li><li><p><code>RFLAGS</code><br>  Ratfor 程序的Fortran编译器参数。</p></li><li><p><code>YFLAGS</code><br>  Yacc文法分析器参数。</p></li></ul><h3 id="9-4-隐含规则链"><a href="#9-4-隐含规则链" class="headerlink" title="9.4 隐含规则链"></a>9.4 隐含规则链</h3><p>有些时候，一个目标可能被一系列的隐含规则所作用。例如，一个[.o]的文件生成，可能会是先被Yacc的[.y]文件先成[.c]，然后再被C的编译器生成。我们把这一系列的隐含规则叫做“隐含规则链”。</p><p>在上面的例子中，如果文件[.c]存在，那么就直接调用C的编译器的隐含规则，如果没有[.c]文件，但有一个[.y]文件，那么Yacc的隐含规则会被调用，生成[.c]文件，然后，再调用C编译的隐含规则最终由[.c]生成[.o]文件，达到目标。</p><p>我们把这种[.c]的文件（或是目标），叫做中间目标。不管怎么样，make会努力自动推导生成目标的一切方法，不管中间目标有多少，其都会执着地把所有的隐含规则和你书写的规则全部合起来分析，努力达到目标。</p><p>在默认情况下，对于中间目标，它和一般的目标有两个地方所不同：第一个不同是除非中间的目标不存在，才会引发中间规则。第二个不同的是，只要目标成功产生，那么，产生最终目标过程中，所产生的中间目标文件会被以<code>rm -f</code>删除。</p><p>通常，一个被makefile指定成目标或是依赖目标的文件不能被当作中介。然而，你可以明显地说明一个文件或是目标是中介目标，你可以使用伪目标<code>.INTERMEDIATE</code>来强制声明。（如：<code>.INTERMEDIATE：mid</code>）<br>你也可以阻止make自动删除中间目标，要做到这一点，你可以使用伪目标<code>.SECONDARY</code>来强制声明（如：<code>.SECONDARY : sec</code>）。你还可以把你的目标，以模式的方式来指定（如：<code>%.o</code>）成伪目标<code>.PRECIOUS</code>的依赖目标，以保存被隐含规则所生成的中间文件。<br>在“隐含规则链”中，禁止同一个目标出现两次或两次以上，这样一来，就可防止在make自动推导时出现无限递归的情况。<br>Make会优化一些特殊的隐含规则，而不生成中间文件。如，从文件<code>foo.c</code>生成目标程序<code>foo</code>，按道理，make会编译生成中间文件<code>foo.o</code>，然后链接成<code>foo</code>，但在实际情况下，这一动作可以被一条<code>cc</code>的命令完成（<code>cc –o foo foo.c</code>），于是优化过的规则就不会生成中间文件。</p><h3 id="9-5-定义模式规则"><a href="#9-5-定义模式规则" class="headerlink" title="9.5 定义模式规则"></a>9.5 定义模式规则</h3><p>你可以使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目标的定义需要有<code>%</code>字符。<code>%</code>的意思是表示一个或多个任意字符。在依赖目标中同样可以使用<code>%</code>，只是依赖目标中的<code>%</code>的取值，取决于其目标。</p><p>有一点需要注意的是，<code>%</code>的展开发生在变量和函数的展开之后，变量和函数的展开发生在make载入Makefile时，而模式规则中的<code>%</code>则发生在运行时。</p><h4 id="模式规则介绍"><a href="#模式规则介绍" class="headerlink" title="模式规则介绍"></a>模式规则介绍</h4><p>模式规则中，至少在规则的<strong>目标定义</strong>中要包含<code>%</code>，否则，就是一般的规则。<br>目标中的<code>%</code>定义表示对文件名的匹配，<code>%</code>表示长度任意的非空字符串。例如：<code>%.c</code>表示以<code>.c</code>结尾的文件名（文件名的长度至少为3），而<code>s.%.c</code>则表示以<code>s.</code>开头，<code>.c</code>结尾的文件名（文件名的长度至少为5）。</p><p>如果”%”定义在目标中，那么，<strong>目标中的”%”的值决定了依赖目标中的”%”的值</strong>，也就是说，目标中的模式的”%”决定了依赖目标中”%”的样子。例如有一个模式规则如下：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%.o : %.c  </span><br><span class="line">    &lt;command ......&gt;</span><br></pre></td></tr></table></figure></p><p>其含义是，指出了怎么从所有的[.c]文件生成相应的[.o]文件的规则。如果要生成的目标是<code>a.o b.o</code>，那么<code>%.c</code>就是<code>a.c b.c</code>。</p><p>一旦依赖目标中的”%”模式被确定，那么，make会被要求去匹配当前目录下所有的文件名，一旦找到，make就会规则下的命令，所以，在模式规则中，目标可能会是多个的，如果有模式匹配出多个目标，make就会产生所有的模式目标，此时，make关心的是依赖的文件名和生成目标的命令这两件事。</p><h4 id="模式规则示例"><a href="#模式规则示例" class="headerlink" title="模式规则示例"></a>模式规则示例</h4><p>下面这个例子表示,把所有的[.c]文件都编译成[.o]文件：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%.o : %.c</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure></p><p>其中，<code>$@</code>表示所有的目标的挨个值，<code>$&lt;</code>表示了所有依赖目标的挨个值。</p><p>下面的这个例子中有两个目标是模式的：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%.tab.c %.tab.h: %.y</span><br><span class="line">     bison -d <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure></p><p>这条规则告诉make把所有的[.y]文件都以<code>bison -d &lt;n&gt;.y</code>执行，然后生成<code>&lt;n&gt;.tab.c</code>和<code>&lt;n&gt;.tab.h</code>文件。（其中，<code>&lt;n&gt;</code>表示一个任意字符串）。如果我们的执行程序<code>foo</code>依赖于文件<code>parse.tab.o</code>和<code>scan.o</code>，并且文件<code>scan.o</code>依赖于文件<code>parse.tab.h</code>，如果<code>parse.y</code>文件被更新了，那么根据上述的规则，<code>bison -d parse.y</code>就会被执行一次，于是，<code>parse.tab.o</code>和<code>scan.o</code>的依赖文件就齐了。</p><h4 id="自动化变量"><a href="#自动化变量" class="headerlink" title="自动化变量"></a>自动化变量</h4><p>在上述的模式规则中，目标和依赖文件都是一系例的文件，那么如何书写一个命令来完成从不同的依赖文件生成相应的目标？因为在每一次的对模式规则的解析时，都会是不同的目标和依赖文件。<br>自动化变量就是完成这个功能的。所谓自动化变量，就是会把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完了。这种自动化变量只应出现在规则的命令中。</p><p>下面是所有的自动化变量及其说明：</p><ul><li><p><code>$@</code><br>  表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，<code>$@</code>就是匹配于目标中模式定义的集合。</p></li><li><p><code>$%</code><br>  <strong>仅当</strong>目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是<code>foo.a(bar.o)</code>，那么，<code>$%&quot;就是&quot;bar.o</code>，<code>$@&quot;就是&quot;foo.a</code>。如果目标不是函数库文件（Unix下是[.a]，Windows下是[.lib]），那么，其值为空。</p></li><li><p><code>$&lt;</code><br>  依赖目标中的第一个目标名字。如果依赖目标是以模式（即<code>%</code>）定义的，那么<code>$&lt;</code>将是符合模式的一系列的文件集。注意，其是一个一个取出来的。</p></li><li><p><code>$?</code><br>  所有比目标新的依赖目标的集合。以空格分隔。</p></li><li><p><code>$^</code><br>  所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。</p></li><li><p><code>$+</code><br>  这个变量很像<code>$^</code>，也是所有依赖目标的集合。只是它不去除重复的依赖目标。</p></li><li><p><code>$*</code><br>  这个变量表示目标模式中<code>%</code>及其之前的部分。如果目标是<code>dir/a.foo.b</code>，并且目标的模式是<code>a.%.b</code>，那么，<code>$*</code>的值就是<code>dir/a.foo</code>。这个变量对于构造有关联的文件名是比较有用。<br>  如果目标中没有模式的定义，那么<code>$*</code>也就不能被推导出，但是，如果目标文件的后缀是make所识别的，那么<code>$*</code>就是除了后缀的那一部分。例如：如果目标是<code>foo.c</code>，因为<code>.c</code>是make所能识别的后缀名，所以，<code>$*</code>的值就是<code>foo</code>。这个特性是GNU make的，很有可能不兼容于其它版本的make。</p></li></ul><p>当你希望只对更新过的依赖文件进行操作时，”$?”在显式规则中很有用，例如，假设有一个函数库文件叫”lib”，其由其它几个object文件更新。那么把object文件打包的比较有效率的Makefile规则是：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lib : foo.o bar.o lose.o win.o</span><br><span class="line">    ar r lib <span class="variable">$?</span></span><br></pre></td></tr></table></figure></p><p>在上述所列出来的自动量变量中。四个变量（<code>$@</code>、<code>$&lt;</code>、<code>$%</code>、<code>$*</code>）在扩展时只会有一个文件，而另三个的值是一个文件列表。</p><p>这七个自动化变量还可以取得文件的目录名或是在当前目录下的符合模式的文件名，只需要搭配上”D”或”F”字样。<br>例如，<code>$(@D)</code>表示<code>$@</code>的目录部分（不以斜杠作为结尾），如果<code>$@</code>值是<code>dir/foo.o</code>，那么<code>$(@D)</code>就是<code>dir</code>，而如果”$@”中没有包含斜杠的话，其值就是”.”（当前目录）。<br><code>$(@F)</code>表示”$@”的文件部分，如果<code>$@</code>值是<code>dir/foo.o</code>，那么<code>$(@F)</code>就是<code>foo.o</code>，<code>$(@F)</code>相当于函数<code>$(notdir $@)</code>。</p><h4 id="模式的匹配"><a href="#模式的匹配" class="headerlink" title="模式的匹配"></a>模式的匹配</h4><p>一般来说，一个目标的模式有一个有前缀或是后缀的<code>%</code>，或是没有前后缀，直接就是一个<code>%</code>。因为<code>%</code>代表一个或多个字符，所以在定义好了的模式中，我们把<code>%</code>所匹配的内容叫做“茎”，例如<code>%.c</code>所匹配的文件<code>test.c</code>中<code>test</code>就是“茎”。因为在目标和依赖目标中同时有<code>%</code>时，依赖目标的“茎”会传给目标，当做目标中的“茎”。</p><p>当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，那么在进行模式匹配时，目录部分会首先被移开，然后进行匹配，成功后，再把目录加回去。在进行“茎”的传递时，我们需要知道这个步骤。例如有一个模式<code>e%t</code>，文件<code>src/eat</code>匹配于该模式，于是<code>src/a</code>就是其“茎”，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式<code>c%r</code>，那么，目标就是<code>src/car</code>。（”茎”被传递）</p><h4 id="重载内建隐含规则"><a href="#重载内建隐含规则" class="headerlink" title="重载内建隐含规则"></a>重载内建隐含规则</h4><p>可以重载内建的隐含规则（或是定义一个全新的），例如你可以重新构造和内建隐含规则不同的命令，如：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%.o : %.c</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CPPFLAGS)</span> <span class="variable">$(CFLAGS)</span> -D<span class="variable">$(date)</span></span><br></pre></td></tr></table></figure></p><p>你可以取消内建的隐含规则，只要不在后面写命令就行。如：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%.o : %.s</span><br></pre></td></tr></table></figure></p><p>同样，你也可以重新定义一个全新的隐含规则，其在隐含规则中的位置取决于你在哪里写下这个规则。朝前的位置就靠前。</p><h3 id="9-6-老式风格的”后缀规则”"><a href="#9-6-老式风格的”后缀规则”" class="headerlink" title="9.6 老式风格的”后缀规则”"></a>9.6 老式风格的”后缀规则”</h3><p>前面所说的<code>%.c:%.o</code>为模式规则，还有一种较老的方式<code>.c.o</code>为后缀规则。后缀规则有两种方式：”双后缀”和”单后缀”。</p><p>双后缀规则定义了一对后缀：目标文件的后缀和依赖目标（源文件）的后缀。如<code>.c.o</code>相当于<code>%o : %c</code>。<br>单后缀规则只定义一个后缀，也就是源文件的后缀。如<code>.c</code>相当于<code>% : %.c</code>。</p><p>后缀规则中所定义的后缀应该是make所认识的，如果一个后缀是make所认识的，那么这个规则就是单后缀规则，而如果两个连在一起的后缀都被make所认识，那就是双后缀规则。<br>例如：<code>.c</code>和<code>.o</code>都是make所知道。因而，如果你定义了一个规则是<code>.c.o</code>那么其就是双后缀规则，意义就是<code>.c</code>是源文件的后缀，<code>.o</code>是目标文件的后缀。如下示例：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">.c.o:</span></span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure></p><p>后缀规则不允许任何的依赖文件，如果有依赖文件的话，那就不是后缀规则，那些后缀统统被认为是文件名，如：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">.c.o: foo.h</span></span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure></p><p>这个例子的意思为文件<code>.c.o</code>依赖于文件<code>foo.h</code>，而不是我们想要的这样：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">%.o: %.c foo.h</span></span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure></p><p>后缀规则中，如果没有命令，那是毫无意义的。因为他也不会移去内建的隐含规则。</p><p>而要让make知道一些特定的后缀，我们可以使用伪目标<code>.SUFFIXES</code>来定义或是删除，如：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">.SUFFIXES: .hack .win</span></span><br></pre></td></tr></table></figure></p><p>把后缀.hack和.win加入后缀列表中的末尾。<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">.SUFFIXES:              # 删除默认的后缀</span></span><br><span class="line"><span class="section">.SUFFIXES: .c .o .h   # 定义自己的后缀</span></span><br></pre></td></tr></table></figure></p><p>先清除默认后缀，后定义自己的后缀列表。</p><p>make的参数<code>-r</code>或<code>-no-builtin-rules</code>也会使用得默认的后缀列表为空。而变量<code>SUFFIXE</code>被用来定义默认的后缀列表，你可以用<code>.SUFFIXES</code>来改变后缀列表，但请不要改变变量<code>SUFFIXE</code>的值。</p><h3 id="9-7-隐含规则搜索算法"><a href="#9-7-隐含规则搜索算法" class="headerlink" title="9.7 隐含规则搜索算法"></a>9.7 隐含规则搜索算法</h3><p>比如我们有一个目标叫 <code>T</code>，下面是搜索目标<code>T</code>的规则的算法。<br>如果目标是<code>archive(member)&quot;</code>的函数库文件模式，那么这个算法会被运行两次，第一次是找目标<code>T</code>，如果没有找到的话，那么进入第二次，第二次会把<code>member</code>当作<code>T</code>来搜索。</p><ol><li><p>把<code>T</code>的目录部分分离出来。叫<code>D</code>，而剩余部分叫<code>N</code>。（如：如果<code>T</code>是<code>src/foo.o</code>，那么，<code>D</code>就是<code>src/</code>，<code>N</code>就是<code>foo.o</code>）</p></li><li><p>创建所有匹配于T或是N的模式规则列表。</p></li><li><p>如果在模式规则列表中有匹配所有文件的模式，如<code>%</code>，那么从列表中移除其它的模式。</p></li><li><p>移除列表中没有命令的规则。</p></li><li><p>对于第一个在列表中的模式规则：<br> 1）推导其”茎”<code>S</code>，<code>S</code>应该是T或是<code>N</code>匹配于模式中<code>%</code>非空的部分。<br> 2）计算依赖文件。把依赖文件中的<code>%</code>都替换成”茎”<code>S</code>。如果目标模式中没有包含斜框字符，而把<code>D</code>加在第一个依赖文件的开头。<br> 3）测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫”理当存在”）<br> 4）如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。</p></li><li><p>如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则：<br> 1）如果规则是终止规则，那就忽略它，继续下一条模式规则。<br> 2）计算依赖文件。（同第5步）<br> 3）测试所有的依赖文件是否存在或是理当存在。<br> 4）对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。<br> 5）如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。</p></li><li><p>如果没有隐含规则可以使用，查看<code>.DEFAULT</code>规则，如果有，采用，把<code>.DEFAULT</code>的命令给<code>T</code>使用。</p></li></ol><p>一旦规则被找到，就会执行其相当的命令，而此时，我们的自动化变量的值才会生成。</p><hr><h2 id="10-使用make更新函数库文件"><a href="#10-使用make更新函数库文件" class="headerlink" title="10 使用make更新函数库文件"></a>10 使用make更新函数库文件</h2><p>函数库文件也就是对Object文件（程序编译的中间文件）的打包文件。在Unix下，一般是由命令”ar”来完成打包工作。</p><h3 id="10-1-函数库文件的成员"><a href="#10-1-函数库文件的成员" class="headerlink" title="10.1 函数库文件的成员"></a>10.1 函数库文件的成员</h3><p>一个函数库文件由多个文件组成。你可以以如下格式指定函数库文件及其组成：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">archive(member)</span><br></pre></td></tr></table></figure></p><p>这个不是一个命令，而一个目标和依赖的定义。一般来说，这种用法基本上就是为了<code>ar</code>命令来服务的。如：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foolib(hack.o) : hack.o</span><br><span class="line">    ar cr foolib hack.o</span><br></pre></td></tr></table></figure></p><p>如果要指定多个member，那就以空格分开，如：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foolib(hack.o kludge.o)</span><br><span class="line"><span class="comment">#等价于：</span></span><br><span class="line">foolib(hack.o) foolib(kludge.o)</span><br></pre></td></tr></table></figure></p><p>还可以使用Shell的文件通配符来定义：<code>foolib(*.o)</code></p><h3 id="10-2-函数库成员的隐含规则"><a href="#10-2-函数库成员的隐含规则" class="headerlink" title="10.2 函数库成员的隐含规则"></a>10.2 函数库成员的隐含规则</h3><p>当make搜索一个目标的隐含规则时，一个特殊的特性是，如果这个目标是<code>a(m)</code>形式的，其会把目标变成<code>(m)</code>。于是，如果我们的成员是<code>%.o</code>的模式定义，并且如果我们使用<code>make foo.a(bar.o)</code>的形式调用Makefile时，隐含规则会去找<code>bar.o</code>的规则，如果没有定义<code>bar.o</code>的规则，那么内建隐含规则生效，make会去找<code>bar.c</code>文件来生成<code>bar.o</code>，如果找得到的话，make执行的命令大致如下：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cc -c bar.c -o bar.o</span><br><span class="line">ar r foo.a bar.o</span><br><span class="line">rm -f bar.o</span><br></pre></td></tr></table></figure></p><h3 id="10-3-函数库文件的后缀规则"><a href="#10-3-函数库文件的后缀规则" class="headerlink" title="10.3 函数库文件的后缀规则"></a>10.3 函数库文件的后缀规则</h3><p>可以使用”后缀规则”和”隐含规则”来生成函数库打包文件，如：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">.c.a:</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$*</span>.o</span><br><span class="line">    <span class="variable">$(AR)</span> r <span class="variable">$@</span> <span class="variable">$*</span>.o</span><br><span class="line">    <span class="variable">$(RM)</span> <span class="variable">$*</span>.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其等效于：</span></span><br><span class="line">(%.o) : %.c</span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$*</span>.o</span><br><span class="line">    <span class="variable">$(AR)</span> r <span class="variable">$@</span> <span class="variable">$*</span>.o</span><br><span class="line">    <span class="variable">$(RM)</span> <span class="variable">$*</span>.o</span><br></pre></td></tr></table></figure></p><h3 id="10-4-注意事项"><a href="#10-4-注意事项" class="headerlink" title="10.4 注意事项"></a>10.4 注意事项</h3><p>在进行函数库打包文件生成时，请小心使用make的并行机制（<code>-j</code>参数）。如果多个ar命令在同一时间运行在同一个函数库打包文件上，就很有可以损坏这个函数库文件。所以，在make未来的版本中，应该提供一种机制来避免并行操作发生在函数打包文件上。</p><p>但就目前而言，你还是应该不要尽量不要使用<code>-j</code>参数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;8-make的运行&quot;&gt;&lt;a href=&quot;#8-make的运行&quot; class=&quot;headerlink&quot; title=&quot;8 make的运行&quot;&gt;&lt;/a&gt;8 make的运行&lt;/h2&gt;&lt;p&gt;一般来说，最简单的就是直接在命令行下输入make命令，make命令会找当前目录的ma
      
    
    </summary>
    
      <category term="教程" scheme="http://yoursite.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Makefile" scheme="http://yoursite.com/tags/Makefile/"/>
    
      <category term="编译" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Makefile学习（二）</title>
    <link href="http://yoursite.com/2018/08/18/makefile(2)/"/>
    <id>http://yoursite.com/2018/08/18/makefile(2)/</id>
    <published>2018-08-18T15:00:00.000Z</published>
    <updated>2020-05-10T07:07:22.075Z</updated>
    
    <content type="html"><![CDATA[<h2 id="5-使用变量"><a href="#5-使用变量" class="headerlink" title="5 使用变量"></a>5 使用变量</h2><p>在Makefile中的定义的变量，就像是C/C++语言中的宏一样，他代表了一个文本字串，在Makefile中执行的时候其会自动原模原样地展开在所使用的地方。其与C/C++所不同的是，你可以在Makefile中改变其值。在Makefile中，变量可以使用在“目标”，“依赖目标”，“命令”或 是Makefile的其它部分中。</p><p>变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有“:”、“#”、“=”或是空字符（空格、回车等）。变量是大小写敏感的，“foo”、“Foo”和“FOO”是三个不同的变量名。传统的Makefile的变量名是全大写的命名方式，但推荐使用大小写搭配的变量名，如：<code>MakeFlags</code>。这样可以避免和系统的变量冲突，而发生意外的事情。</p><p>有一些变量是很奇怪字串，如<code>$&lt;</code>、<code>$@</code>、<code>$^</code>等，这些是自动化变量。</p><h3 id="5-1-变量的基础"><a href="#5-1-变量的基础" class="headerlink" title="5.1 变量的基础"></a>5.1 变量的基础</h3><p>变量在声明时需要给予初值，而在使用时，需要给在变量名前加上<code>$</code>符号，但最好用小括号<code>()</code>或是大括号<code>{}</code>把变量给包括起来。如果要使用真实的<code>$</code>字符，那么需要用<code>$$</code>来表示。</p><p>变量可以使用在许多地方，如规则中的“目标”、“依赖”、“命令”以及新的变量中。<br>先看一个例子：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">objects = program.o foo.o utils.o</span><br><span class="line"></span><br><span class="line">program : <span class="variable">$(objects)</span></span><br><span class="line">    cc -o program <span class="variable">$(objects)</span></span><br><span class="line"><span class="variable">$(objects)</span> : defs.h</span><br></pre></td></tr></table></figure></p><p>变量会在使用它的地方精确地展开，就像C/C++中的宏一样，例如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">foo = c</span><br><span class="line">prog.o : prog.<span class="variable">$(foo)</span></span><br><span class="line">    <span class="variable">$(foo)</span><span class="variable">$(foo)</span> -<span class="variable">$(foo)</span> prog.<span class="variable">$(foo)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#展开后得到：</span></span><br><span class="line">prog.o : prog.c</span><br><span class="line">    cc -c prog.c</span><br></pre></td></tr></table></figure><p>当然，千万不要在你的Makefile中这样干，这里只是举个例子来表明Makefile中的变量在使用处展开的真实样子。可见其就是一个“替代”的原理。</p><h3 id="5-2-变量中的变量"><a href="#5-2-变量中的变量" class="headerlink" title="5.2 变量中的变量"></a>5.2 变量中的变量</h3><p>将变量赋值给变量共有两种方式，分别是</p><ul><li><code>=</code></li><li><code>:=</code></li></ul><p>第一种方式为全局搜索变量，第二种方式为只搜索上面的变量。<br>比如：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">y = <span class="variable">$(x)</span> bar</span><br><span class="line">x = foo</span><br><span class="line"><span class="comment"># $(y) 的值为 foo bar</span></span><br><span class="line"></span><br><span class="line">y := <span class="variable">$(x)</span> bar</span><br><span class="line">x := foo</span><br><span class="line"><span class="comment"># $(y) 的值为 bar</span></span><br></pre></td></tr></table></figure></p><p>第一种方式的好处是可以在变量中使用后面定义的变量，坏处是可能造成递归，且如果在变量中使用函数，这种方式会让我们的make运行时非常慢。他会使用得两个make的函数<code>wildcard</code>和<code>shell</code>发生不可预知的错误。因为你不会知道这两个函数会被调用多少次。</p><p>一个复杂的例子，其中包括了make的函数、条件表达式和一个系统变量“MAKELEVEL”的使用：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (0,$&#123;MAKELEVEL&#125;)</span><br><span class="line">cur-dir   := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line">whoami    := <span class="variable">$(<span class="built_in">shell</span> whoami)</span></span><br><span class="line">host-type := <span class="variable">$(<span class="built_in">shell</span> arch)</span></span><br><span class="line">MAKE := $&#123;MAKE&#125; host-type=$&#123;host-type&#125; whoami=$&#123;whoami&#125;</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure></p><p>对于系统变量<code>MAKELEVEL</code>，其意思是，如果我们的make有一个嵌套执行的动作，那么，这个变量会记录了我们的当前Makefile的调用层数。</p><p>下面再介绍两个定义变量时我们需要知道的，请先看一个例子，如果我们要定义一个变量，其值是一个空格，那么我们可以这样来：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nullstring :=</span><br><span class="line">space := <span class="variable">$(nullstring)</span> <span class="comment"># end of the line</span></span><br></pre></td></tr></table></figure></p><p><code>nullstring</code>是一个Empty变量，其中什么也没有，而我们的space的值是一个空格。因为在操作符的右边是很难描述一个空格的，这里采用的技术很管用，先用一个Empty变量来标明变量的值开始了，而后面采用<code>#</code>注释符来表示变量定义的终止，这样我们可以定义出其值是一个空格的变量。注意这里关于<code>#</code>的使用，注释符<code>#</code>的这种特性值得我们注意，如果我们这样定义一个变量：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir := /foo/bar    <span class="comment"># directory to put the frobs in</span></span><br></pre></td></tr></table></figure></p><p><code>dir</code>这个变量的值是<code>/foo/bar</code>，后面还跟了4个空格，如果我们这样使用这样变量来指定别的目录——<code>$(dir)/file</code>那么就完蛋了，这点需要注意。</p><p>还有一个比较有用的操作符是<code>?=</code>，先看示例：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FOO ?= bar</span><br></pre></td></tr></table></figure></p><p>其含义是，如果<code>FOO</code>没有被定义过，那么变量<code>FOO</code>的值就是<code>bar</code>，如果<code>FOO</code>先前被定义过，那么这条语将什么也不做，其等价于：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">origin</span> FOO)</span>, undefined)</span><br><span class="line">    FOO = bar</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure></p><h3 id="5-3-变量高级用法"><a href="#5-3-变量高级用法" class="headerlink" title="5.3 变量高级用法"></a>5.3 变量高级用法</h3><h4 id="变量值的替换"><a href="#变量值的替换" class="headerlink" title="变量值的替换"></a>变量值的替换</h4><p>我们可以替换变量中的共有的部分，其格式是<code>$(var:a=b)</code>或是<code>${var:a=b}</code>，其意思是，把变量<code>var</code>中所有以<code>a</code>字串结尾的<code>a</code>替换成<code>b</code>字串。这里的“结尾”意思是“空格”或是“结束符”。</p><p>举例说明：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo := a.o b.o c.o</span><br><span class="line">bar := $(foo:.o=.c)</span><br></pre></td></tr></table></figure></p><p>这个示例中，我们先定义了一个“$(foo)”变量，而第二行的意思是把“$(foo)”中所有以“.o”字串“结尾”全部替换成“.c”，所以我们的“$(bar)”的值就是“a.c b.c c.c”。</p><h4 id="把变量的值再当成变量"><a href="#把变量的值再当成变量" class="headerlink" title="把变量的值再当成变量"></a>把变量的值再当成变量</h4><p>例子：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = y</span><br><span class="line">y = z</span><br><span class="line">a := $(<span class="variable">$(x)</span>)</span><br></pre></td></tr></table></figure></p><p>在这个例子中，<code>$(x)</code>的值是<code>y</code>，所以<code>$($(x))</code>就是<code>$(y)</code>，于是<code>$(a)</code>的值就是<code>z</code>。<br>注意，是<code>x=y</code>，而不是<code>x=$(y)</code>。如果是<code>x=$(y)</code>，那么<code>x</code>的值就是<code>z</code>而不是<code>y</code>了。</p><p>更复杂的例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = variable1</span><br><span class="line">variable2 := Hello</span><br><span class="line">y = <span class="variable">$(<span class="built_in">subst</span> 1,2,<span class="variable">$(x)</span>)</span></span><br><span class="line">z = y</span><br><span class="line">a := $($(<span class="variable">$(z)</span>))</span><br></pre></td></tr></table></figure><p>这个例子中，<code>$($($(z)))</code>扩展为<code>$($(y))</code>，而其再次被扩展为<code>$($(subst 1,2,$(x)))</code>。<code>$(x)</code>的值是<code>variable1</code>，<code>subst</code>函数把<code>variable1</code>中的所有“1”字串替换成“2”字串，于是， <code>variable1</code>变成<code>variable2</code>，再取其值，所以，最终，<code>$(a)</code>的值就是<code>$(variable2)</code>的值——<code>Hello</code>。</p><p>使用多个变量的名字组成一个变量的名字：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">first_second = Hello</span><br><span class="line">a = first</span><br><span class="line">b = second</span><br><span class="line">all = $($a_$b)</span><br></pre></td></tr></table></figure></p><p>这里<code>$a_$b$</code>展开为<code>first_second</code>，最后<code>$first_second</code>的值为<code>Hello</code></p><p>结合变量替换：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a_objects := a.o b.o c.o</span><br><span class="line">1_objects := 1.o 2.o 3.o</span><br><span class="line">sources := $(<span class="variable">$(a1)</span>_objects:.o=.c)</span><br></pre></td></tr></table></figure></p><p>如果<code>$a1</code>的值为<code>1</code>，最终的结果是<code>1.c 2.c 3.c</code>；如果<code>$a1</code>的值是<code>a</code>，最终的结果是<code>a.c b.c c.c</code></p><p>“把变量的值再当成变量”这种技术，同样可以用在操作符的左边：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dir = foo</span><br><span class="line"><span class="variable">$(dir)</span>_sources := <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*.c)</span></span><br><span class="line"><span class="keyword">define</span> <span class="variable">$(dir)</span>_print</span><br><span class="line">lpr $(<span class="variable">$(dir)</span>_sources)</span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure></p><p>这个例子中定义了三个变量：<code>dir</code>，<code>foo_sources</code>和<code>foo_print</code>。</p><h3 id="5-4-追加变量值"><a href="#5-4-追加变量值" class="headerlink" title="5.4 追加变量值"></a>5.4 追加变量值</h3><p>我们可以使用“+=”操作符给变量追加值，如：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o foo.o bar.o utils.o</span><br><span class="line">objects += another.o</span><br></pre></td></tr></table></figure></p><p>于是，我们的<code>$(objects)</code>值变成：<code>main.o foo.o bar.o utils.o another.o</code></p><p>如果变量之前没有定义过，那么，“+=”会自动变成“=”，如果前面有变量定义，那么“+=”会继承于前次操作的赋值符。如果前一次的是“:=”，那么“+=”会以“:=”作为其赋值符，如：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">variable := value</span><br><span class="line">variable += more</span><br><span class="line"><span class="comment">#等价于：</span></span><br><span class="line">variable := value</span><br><span class="line">variable := <span class="variable">$(variable)</span> more</span><br></pre></td></tr></table></figure></p><p>但如果是这种情况：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">variable = value</span><br><span class="line">variable += more</span><br></pre></td></tr></table></figure></p><p>由于前次的赋值符是<code>=</code>，所以<code>+=</code>也会以<code>=</code>来做为赋值，那么岂不会发生变量的递补归定义，这是很不好的，所以make会自动为我们解决这个问题，我们不必担心这个问题。</p><h3 id="5-5-override指示符"><a href="#5-5-override指示符" class="headerlink" title="5.5 override指示符"></a>5.5 override指示符</h3><p>如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用<code>override</code>指示符。其语法是：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> &lt;variable&gt; = &lt;value&gt;</span><br><span class="line"><span class="keyword">override</span> &lt;variable&gt; := &lt;value&gt;</span><br><span class="line"><span class="comment">#追加：</span></span><br><span class="line"><span class="keyword">override</span> &lt;variable&gt; += &lt;more text&gt;</span><br><span class="line"><span class="comment">#多行变量</span></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">define</span> foo</span><br><span class="line">bar</span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure></p><h3 id="5-6-多行变量"><a href="#5-6-多行变量" class="headerlink" title="5.6 多行变量"></a>5.6 多行变量</h3><p>多行变量就是前面所述的<code>define...endef</code>。使用<code>define</code>关键字设置变量的值可以有换行，这有利于定义一系列的命令。<br><code>define</code>指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以<code>endef</code>关键字结束。其工作方式和<code>=</code>操作符一样。变量的值可以包含函 数、命令、文字，或是其它变量。因为命令需要以<code>Tab</code>键开头，所以如果你用<code>define</code>定义的命令变量中没有以<code>Tab</code>键开头，那么make就不会把其认为是命令。注意这里是在使用时以<code>Tab</code>开头。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> two-lines</span><br><span class="line">echo foo</span><br><span class="line">echo <span class="variable">$(bar)</span></span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line">使用时：</span><br><span class="line">    $(two-lines)</span><br></pre></td></tr></table></figure><h3 id="5-7-环境变量"><a href="#5-7-环境变量" class="headerlink" title="5.7 环境变量"></a>5.7 环境变量</h3><p>make运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中，但是如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。（如果make指定了<code>-e</code>参数，那么，系统环境变量将覆盖Makefile中定义的变量）</p><p>因此，如果我们在环境变量中设置了<code>CFLAGS</code>环境变量，那么我们就可以在所有的Makefile中使用这个变量了。这对于我们使用统一的编译参数有比较大的好处。如果Makefile中定义了<code>CFLAGS</code>，那么则会使用Makefile中的这个变量，如果没有定义则使用系统环境变量的值，一个共性和个性的统一，很像“全局变量”和“局部变量”的特性。</p><p>当make嵌套调用时（参见前面的“嵌套调用”章节），上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层Makefile传递，则需要使用<code>exprot</code>关键字来声明。</p><h3 id="5-8-目标变量"><a href="#5-8-目标变量" class="headerlink" title="5.8 目标变量"></a>5.8 目标变量</h3><p>前面我们所讲的在Makefile中定义的变量都是“全局变量”，在整个文件，我们都可以访问这些变量。当然，“自动化变量”除外，如<code>$&lt;</code>等这种类量的自动化变量就属于“规则型变量”，这种变量的值依赖于规则的目标和依赖目标的定义。</p><p>同样可以为某个目标设置局部变量，这种变量被称为“Target-specific Variable”，它可以和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。</p><p>其语法是：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;target ...&gt; : &lt;variable-assignment&gt;</span><br><span class="line">&lt;target ...&gt; : overide &lt;variable-assignment&gt;</span><br></pre></td></tr></table></figure></p><p><code>&lt;variable-assignment&gt;</code>可以是前面讲过的各种赋值表达式，如<code>=</code>、<code>:=</code>、<code>+=</code>或是<code>？=</code>。<br>第二个语法是针对于make命令行带入的变量，或是系统环境变量。</p><p>当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去。举例：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">prog : CFLAGS = -g</span><br><span class="line">prog : prog.o foo.o bar.o</span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> prog.o foo.o bar.o</span><br><span class="line"></span><br><span class="line">prog.o : prog.c</span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> prog.c</span><br><span class="line"></span><br><span class="line">foo.o : foo.c</span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> foo.c</span><br><span class="line"></span><br><span class="line">bar.o : bar.c</span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> bar.c</span><br></pre></td></tr></table></figure></p><p>在这个示例中，不管全局的<code>$(CFLAGS)</code>的值是什么，在<code>prog</code>目标，以及其所引发的所有规则中（<code>prog.o</code> <code>foo.o</code> <code>bar.o</code>的规则），<code>$(CFLAGS)</code>的值都是<code>-g</code></p><h3 id="5-9-模式变量"><a href="#5-9-模式变量" class="headerlink" title="5.9 模式变量"></a>5.9 模式变量</h3><p>上面介绍的目标变量，是指在一个指定目标上该变量生效，而模式变量是在一种给定“模式”上，把变量定义在符合这种模式的所有目标上。</p><p>我们知道，make的“模式”一般是至少含有一个<code>%</code>的，所以，我们可以以如下方式给所有以<code>.o</code>结尾的目标定义目标变量：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%.o : CFLAGS = -O</span><br></pre></td></tr></table></figure></p><p>同样，模式变量的语法和“目标变量”一样：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;pattern ...&gt; : &lt;variable-assignment&gt;</span><br><span class="line">&lt;pattern ...&gt; : <span class="keyword">override</span> &lt;variable-assignment&gt;</span><br></pre></td></tr></table></figure></p><p><code>override</code>同样是针对于系统环境传入的变量，或是make命令行指定的变量。</p><h2 id="6-使用条件判断"><a href="#6-使用条件判断" class="headerlink" title="6 使用条件判断"></a>6 使用条件判断</h2><p>使用条件判断，可以让make根据运行时的不同情况选择不同的执行分支。条件表达式可以是比较变量的值，或是比较变量和常量的值。</p><h3 id="6-1-示例"><a href="#6-1-示例" class="headerlink" title="6.1 示例"></a>6.1 示例</h3><p>下面的例子，判断<code>$(CC)</code>变量是否<code>gcc</code>，如果是的话，则使用GNU函数编译目标。<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">libs_for_gcc = -lgnu</span><br><span class="line">normal_libs =</span><br><span class="line"></span><br><span class="line"><span class="section">foo: <span class="variable">$(objects)</span></span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CC)</span>,gcc)</span><br><span class="line">    <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(libs_for_gcc)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(normal_libs)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure></p><p>我们可以从上面的示例中看到三个关键字：<code>ifeq</code>、<code>else</code>和<code>endif</code>。<code>ifeq</code>的意思表示条件语句的开始，并指定一个条件表达式，表达式包含两个参数，以逗号分隔，表达式以圆括号括起。<code>else</code>表示条件表达式为假的情况。<code>endif</code>表示一个条件语句的结束，任何一个条件表达式都应该以<code>endif</code>结束。</p><p>当然，我们还可以把上面的那个例子写得更简洁一些：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">libs_for_gcc = -lgnu</span><br><span class="line">normal_libs =</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CC)</span>,gcc)</span><br><span class="line">    libs=<span class="variable">$(libs_for_gcc)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    libs=<span class="variable">$(normal_libs)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="section">foo: <span class="variable">$(objects)</span></span></span><br><span class="line">    <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(libs)</span></span><br></pre></td></tr></table></figure></p><h3 id="6-2-语法"><a href="#6-2-语法" class="headerlink" title="6.2 语法"></a>6.2 语法</h3><p>条件表达式的语法为：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;conditional-directive&gt;</span><br><span class="line">&lt;text-if-true&gt;</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure></p><p>以及：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;conditional-directive&gt;</span><br><span class="line">&lt;text-if-true&gt;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&lt;text-if-false&gt;</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure></p><p><code>&lt;conditional-directive&gt;</code>可以是<code>ifeq</code>/<code>ifneq</code>/<code>ifdef</code>/<code>ifndef</code>。</p><p><code>ifeq</code>与<code>ifneq</code>共有五种表达，其中后四个都类似：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (&lt;arg1&gt;, &lt;arg2&gt;)</span><br><span class="line"><span class="keyword">ifeq</span> '&lt;arg1&gt;' '&lt;arg2&gt;'</span><br><span class="line"><span class="keyword">ifeq</span> <span class="string">"&lt;arg1&gt;"</span> <span class="string">"&lt;arg2&gt;"</span></span><br><span class="line"><span class="keyword">ifeq</span> <span class="string">"&lt;arg1&gt;"</span> '&lt;arg2&gt;'</span><br><span class="line"><span class="keyword">ifeq</span> '&lt;arg1&gt;' <span class="string">"&lt;arg2&gt;"</span></span><br></pre></td></tr></table></figure></p><p><code>ifdef</code>与<code>ifndef</code>的表达比较简单：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifdef</span> &lt;variable-name&gt;</span><br><span class="line"><span class="keyword">ifndef</span> &lt;variable-name&gt;</span><br></pre></td></tr></table></figure></p><p>在<code>&lt;conditional-directive&gt;</code>这一行上，多余的空格是被允许的，但是不能以[Tab]键做为开始（不然就被认为是命令）。而注释符<code>#</code>同样也是安全的。<code>else</code>和<code>endif</code>也一样，只要不是以[Tab]键开始就行了。</p><p>特别注意的是，make是在读取Makefile时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以最好不要把自动化变量（如<code>$@</code>等）放入条件表达式中（作为条件被判断），因为自动化变量是在运行时才有的。</p><hr><h2 id="7-使用函数"><a href="#7-使用函数" class="headerlink" title="7 使用函数"></a>7 使用函数</h2><h3 id="7-1-函数的调用语法"><a href="#7-1-函数的调用语法" class="headerlink" title="7.1 函数的调用语法"></a>7.1 函数的调用语法</h3><p>函数调用，很像变量的使用，也是以<code>$</code>来标识的，其语法如下：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&lt;function&gt; &lt;arguments&gt;)</span><br><span class="line"><span class="comment">#或是</span></span><br><span class="line">$&#123;&lt;function&gt; &lt;arguments&gt;&#125;</span><br></pre></td></tr></table></figure></p><p>这里，<code>&lt;function&gt;</code>就是函数名，make支持的函数不多。<code>&lt;arguments&gt;</code>是函数的参数，参数间以逗号“,” 分隔，而函数名和参数之间以“空格”分隔。</p><p>函数调用以<code>$</code>开头，以圆括号或花括号把函数名和参数括起。    </p><p>示例：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">comma:= ,</span><br><span class="line">empty:=</span><br><span class="line">space:= <span class="variable">$(empty)</span> <span class="variable">$(empty)</span></span><br><span class="line">foo:= a b c</span><br><span class="line">bar:= <span class="variable">$(<span class="built_in">subst</span> <span class="variable">$(space)</span>,<span class="variable">$(comma)</span>,<span class="variable">$(foo)</span>)</span></span><br></pre></td></tr></table></figure></p><p>在这个示例中，<code>$(comma)</code>的值是一个逗号。<code>$(space)</code>使用了<code>$(empty)</code>定义了一个空格，<code>$(foo)</code>的值是<code>a b c</code>，<code>$(bar)</code>的定义用，调用了函数<code>subst</code>，这是一个替换函数，这个函数有三个参数，第一个参数是被替换字串，第二个参数是替换字串，第三个参数是替换操作作用的字串。这个函数也就是把<code>$(foo)</code>中的空格替换成逗号，所以<code>$(bar)</code>的值是<code>a,b,c</code>。</p><h3 id="7-2-字符串处理函数"><a href="#7-2-字符串处理函数" class="headerlink" title="7.2 字符串处理函数"></a>7.2 字符串处理函数</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#字符串替换函数</span></span><br><span class="line"><span class="variable">$(<span class="built_in">subst</span> &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">#模式字符串替换函数             </span></span><br><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">#去空格函数</span></span><br><span class="line"><span class="variable">$(<span class="built_in">strip</span> &lt;string&gt;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查找字符串函数</span></span><br><span class="line"><span class="variable">$(<span class="built_in">findstring</span> &lt;find&gt;,&lt;in&gt;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#过滤函数</span></span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span> &lt;pattern...&gt;,&lt;text&gt;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#反向过滤函数</span></span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span>-out &lt;pattern...&gt;,&lt;text&gt;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#排序函数</span></span><br><span class="line"><span class="variable">$(<span class="built_in">sort</span> &lt;list&gt;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#取单词函数</span></span><br><span class="line"><span class="variable">$(<span class="built_in">word</span> &lt;n&gt;,&lt;text&gt;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#取单词串函数</span></span><br><span class="line"><span class="variable">$(<span class="built_in">wordlist</span> &lt;s&gt;,&lt;e&gt;,&lt;text&gt;)</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">#单词个数函数</span></span><br><span class="line"><span class="variable">$(words &lt;text&gt;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#首单词函数</span></span><br><span class="line"><span class="variable">$(<span class="built_in">firstword</span> &lt;text&gt;)</span></span><br></pre></td></tr></table></figure><ul><li><p><code>$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)</code><br>名称：字符串替换函数——subst。<br>功能：把字串<code>&lt;text&gt;</code>中的<code>&lt;from&gt;</code>字符串替换成<code>&lt;to&gt;</code>。<br>返回：函数返回被替换过后的字符串。<br>示例：</p>  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">subst</span> ee,EE,feet on the street)</span></span><br></pre></td></tr></table></figure><p>  把<code>feet on the street</code>中的<code>ee</code>替换成<code>EE</code>，返回结果是<code>fEEt on the strEEt</code>。</p></li><li><p><code>$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</code><br>名称：模式字符串替换函数——patsubst。<br>功能：查找<code>&lt;text&gt;</code>中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式<code>&lt;pattern&gt;</code>，如果匹配的话，则以<code>&lt;replacement&gt;</code>替换。这里，<code>&lt;pattern&gt;</code>可以包括通配符<code>%</code>，表示任意长度的字串。如果<code>&lt;replacement&gt;</code>中也包含<code>%</code>，那么，<code>&lt;replacement&gt;</code>中的这个<code>%</code>将是<code>&lt;pattern&gt;</code>中的那个<code>%</code>所代表的字串。（可以用<code>/</code>来转义，以<code>/%</code>来表示真实含义的<code>%</code>字符）<br>返回：函数返回被替换过后的字符串。<br>示例：</p>  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,x.c.c bar.c)</span></span><br></pre></td></tr></table></figure><p>把字串<code>x.c.c bar.c</code>符合模式<code>[%.c]</code>的单词替换成<code>[%.o]</code>，返回结果是<code>x.c.o bar.o</code><br>备注：这与5.3节中的变量替换很相似，上述示例如果写为：<code>$(x.c.c bar.c: .c = .o)</code>，则返回有些许不同，会返回<code>x.o.o bar.o</code></p></li><li><p><code>$(strip &lt;string&gt;)</code><br>名称：去空格函数——strip。<br>功能：去掉<code>&lt;string&gt;</code>字串中<strong>开头和结尾</strong>的空字符。<br>返回：返回被去掉空格的字符串值。<br>示例：</p>  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">strip</span> a b c )</span></span><br></pre></td></tr></table></figure><p>把字串<code>a b c</code>去到开头和结尾的空格，结果是<code>a b c</code>。</p></li><li><p><code>$(findstring &lt;find&gt;,&lt;in&gt;)</code><br>名称：查找字符串函数——findstring。<br>功能：在字串<code>&lt;in&gt;</code>中查找<code>&lt;find&gt;</code>字串。<br>返回：如果找到，那么返回<code>&lt;find&gt;</code>，否则返回空字符串。<br>示例：</p>  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">findstring</span> a,a b c)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">findstring</span> a,b c)</span></span><br></pre></td></tr></table></figure><p>第一个函数返回<code>a</code>字符串，第二个返回“”字符串（空字符串）</p></li><li><p><code>$(filter &lt;pattern...&gt;, &lt;text&gt;)</code><br>名称：过滤函数——filter。<br>功能：以<code>&lt;pattern&gt;</code>模式过滤<code>&lt;text&gt;</code>字符串中的单词，<strong>保留</strong>符合模式<code>&lt;pattern&gt;</code>的单词。可以有多个模式。<br>返回：返回符合模式<code>&lt;pattern&gt;</code>的字串。<br>示例：</p>  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sources := foo.c bar.c baz.s ugh.h</span><br><span class="line"><span class="section">foo: <span class="variable">$(sources)</span></span></span><br><span class="line">  cc <span class="variable">$(<span class="built_in">filter</span> %.c %.s, <span class="variable">$(sources)</span>)</span> -o foo</span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span> %.c %.s,<span class="variable">$(sources)</span>)</span></span><br></pre></td></tr></table></figure><p>返回的值是<code>foo.c bar.c baz.s</code>。</p></li><li><p><code>$(filter-out &lt;pattern...&gt;,&lt;text&gt;)</code><br>名称：反过滤函数——filter-out。<br>功能：以<code>&lt;pattern&gt;</code>模式过滤<code>&lt;text&gt;</code>字符串中的单词，<strong>去除</strong>符合模式<code>&lt;pattern&gt;</code>的单词。可以有多个模式。<br>返回：返回不符合模式<code>&lt;pattern&gt;</code>的字串。<br>示例：变量定义与上相同，<code>$(filter-out %.c %.s,$(sources))</code>，返回值是<code>ugh.h</code>。      </p></li><li><p><code>$(sort &lt;list&gt;)</code><br>名称：排序函数——sort。<br>功能：给字符串<code>&lt;list&gt;</code>中的单词排序（升序）。<br>返回：返回排序后的字符串。<br>示例：<code>$(sort foo bar lose)</code>返回<code>bar foo lose</code>。<br>备注：sort函数会去掉<code>&lt;list&gt;</code>中相同的单词。</p></li><li><p><code>(word &lt;n&gt;,&lt;text&gt;)</code><br>名称：取单词函数——word。<br>功能：取字符串<code>&lt;text&gt;</code>中第<code>&lt;n&gt;</code>个单词。（从一开始）<br>返回：返回字符串<code>&lt;text&gt;</code>中第<code>&lt;n&gt;</code>个单词。如果<code>&lt;n&gt;</code>比<code>&lt;text&gt;</code>中的单词数要大，那么返回空字符串。<br>示例：$(word 2, foo bar baz)返回值是“bar”。</p></li><li><p><code>(wordlist &lt;s&gt;,&lt;e&gt;,&lt;text&gt;)</code><br>名称：取单词串函数——wordlist。<br>功能：从字符串<code>&lt;text&gt;</code>中取从<code>&lt;s&gt;</code>开始到<code>&lt;e&gt;</code>的单词串。<code>&lt;s&gt;</code>和<code>&lt;e&gt;</code>是一个数字。<br>返回：返回字符串<code>&lt;text&gt;</code>中从<code>&lt;s&gt;</code>到<code>&lt;e&gt;</code>的单词字串。如果<code>&lt;s&gt;</code>大于<code>&lt;text&gt;</code>的单词数，那么返回空字符串。如果<code>&lt;e&gt;</code>大于<code>&lt;text&gt;</code>的单词数，那么返回从<code>&lt;s&gt;</code>开始，到<code>&lt;text&gt;</code>结束的单词串。<br>示例： <code>$(wordlist 2, 3, foo bar baz)</code>返回值是<code>bar baz</code>。</p></li><li><p><code>$(words &lt;text&gt;)</code><br>名称：单词个数统计函数——words。<br>功能：统计<code>&lt;text&gt;</code>中字符串中的单词个数。<br>返回：返回<code>&lt;text&gt;</code>中的单词数。<br>示例：<code>$(words, foo bar baz)</code>返回值是<code>3</code>。<br>备注：如果我们要取<code>&lt;text&gt;</code>中最后的一个单词，我们可以这样：<code>$(word $(words &lt;text&gt;),&lt;text&gt;)</code>。</p></li><li><p><code>$(firstword &lt;text&gt;)</code><br>名称：首单词函数——firstword。<br>功能：取字符串&lt;<code>text&gt;</code>中的第一个单词。<br>返回：返回字符串<code>&lt;text&gt;</code>的第一个单词。<br>示例：<code>$(firstword foo bar)</code>返回值是<code>foo</code>。<br>备注：这个函数可以用word函数来实现：<code>$(word 1, &lt;text&gt;)</code>。</p></li></ul><p>以上，是所有的字符串操作函数，如果搭配混合使用，可以完成比较复杂的功能。这里，举一个现实中应用的例子。我们知道，make使用<code>VPATH</code>变量来指定“依赖文件”的搜索路径。于是，我们可以利用这个搜索路径来指定编译器对头文件的搜索路径参数<code>CFLAGS</code>，如：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> CFLAGS += <span class="variable">$(<span class="built_in">patsubst</span> %,-I%,$(<span class="built_in">subst</span> :, ,<span class="variable">$(VPATH)</span>)</span>)</span><br></pre></td></tr></table></figure></p><p>如果我们的<code>$(VPATH)</code>值是<code>src:../headers</code>，那么<code>$(patsubst %,-I%,$(subst :, ,$(VPATH)))</code>将返回<code>-Isrc -I../headers</code>（所有单词的前面加-I），这正是cc或gcc搜索头文件路径的参数。</p><h3 id="7-3-文件名操作函数"><a href="#7-3-文件名操作函数" class="headerlink" title="7.3 文件名操作函数"></a>7.3 文件名操作函数</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#取目录函数</span></span><br><span class="line"><span class="variable">$(<span class="built_in">dir</span> &lt;names...&gt;)</span></span><br><span class="line"><span class="comment">#从文件名序列&lt;names&gt;中取出目录部分。目录部分是指最后一个反斜杠（“/”）之前的部分。如果没有反斜杠，那么返回“./”。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#取文件函数</span></span><br><span class="line"><span class="variable">$(<span class="built_in">notdir</span> &lt;names...&gt;)</span></span><br><span class="line"><span class="comment">#从文件名序列&lt;names&gt;中取出非目录部分。非目录部分是指最后一个反斜杠（“/”）之后的部分。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#取后缀函数</span></span><br><span class="line"><span class="variable">$(<span class="built_in">suffix</span> &lt;names...&gt;)</span></span><br><span class="line"><span class="comment">#从文件名序列&lt;names&gt;中取出各个文件名的后缀。返回一个后缀序列。（没有.的项就无视）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#取前缀函数</span></span><br><span class="line"><span class="variable">$(<span class="built_in">basename</span> &lt;names...&gt;)</span></span><br><span class="line"><span class="comment">#从文件名序列&lt;names&gt;中取出各个文件名的前缀部分。返回一个前缀序列。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#加后缀函数</span></span><br><span class="line"><span class="variable">$(<span class="built_in">addsuffix</span> &lt;<span class="built_in">suffix</span>&gt;,&lt;names...&gt;)</span></span><br><span class="line"><span class="comment">#把后缀&lt;suffix&gt;加到&lt;names&gt;中的每个单词后面。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#加前缀函数</span></span><br><span class="line"><span class="variable">$(<span class="built_in">addprefix</span> &lt;prefix&gt;,&lt;names...&gt;)</span></span><br><span class="line"><span class="comment">#把前缀&lt;prefix&gt;加到&lt;names&gt;中的每个单词后面。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#连接函数</span></span><br><span class="line"><span class="variable">$(<span class="built_in">join</span> &lt;list1&gt;,&lt;list2&gt;)</span></span><br><span class="line"><span class="comment">#把&lt;list2&gt;中的单词对应地加到&lt;list1&gt;的单词后面。如果&lt;list1&gt;的单词个数要比&lt;list2&gt;的多，那么，&lt;list1&gt;中的多出来的单词将保持原样。如果&lt;list2&gt;的单词个数要比&lt;list1&gt;多，那么，&lt;list2&gt;多出来的单词将被复制到&lt;list2&gt;中。</span></span><br></pre></td></tr></table></figure><h3 id="7-4-foreach函数"><a href="#7-4-foreach函数" class="headerlink" title="7.4 foreach函数"></a>7.4 foreach函数</h3><p><code>foreach</code>函数和别的函数非常的不一样。因为这个函数是用来做循环用的，Makefile中的<code>foreach</code>函数几乎是仿照于Unix标准Shell（/bin/sh）中的for语句，或是C-Shell（/bin/csh）中的foreach语句而构建的。其语法为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)</span><br></pre></td></tr></table></figure></p><p>这个函数的意思是，把参数<code>&lt;list&gt;</code>中的单词逐一取出放到参数<code>&lt;var&gt;</code>所指定的变量中，然后再执行<code>&lt;text&gt;</code>所包含的表达式。每一次<code>&lt;text&gt;</code>会返回一个字符串，循环过程中，<code>&lt;text&gt;</code>的所返回的每个字符串会以空格分隔，最后当整个循环结束时，<code>&lt;text&gt;</code>所返回的每个字符串所组成的整个字符串（以空格分隔）将会是<code>foreach</code>函数的返回值。</p><p>例子：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">names := a b c d</span><br><span class="line">files := <span class="variable">$(<span class="built_in">foreach</span> n,<span class="variable">$(names)</span>,<span class="variable">$(n)</span>.o)</span></span><br></pre></td></tr></table></figure></p><p>上面的例子中，<code>$(name)</code>中的单词会被挨个取出，并存到变量<code>n</code>中，<code>$(n).o</code>每次根据<code>$(n)</code>计算出一个值，这些值以空格分隔，最后作为<code>foreach</code>函数的返回，所以，<code>$(files)</code>的值是<code>a.o b.o c.o d.o</code>。</p><h3 id="7-5-if函数"><a href="#7-5-if函数" class="headerlink" title="7.5 if函数"></a>7.5 if函数</h3><p>if函数的语法为：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">if</span> &lt;condition&gt;,&lt;then-part&gt;)</span></span><br><span class="line"><span class="comment">#或者是</span></span><br><span class="line"><span class="variable">$(<span class="built_in">if</span> &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt;)</span></span><br></pre></td></tr></table></figure></p><p>可见，if函数可以包含“else”部分，或是不含。即if函数的参数可以是两个，也可以是三个。<br><code>&lt;condition&gt;</code>参数是if的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是，<code>&lt;then-part&gt;</code>会被计算，否则<code>&lt;else-part&gt;</code>会被计算。</p><p>而if函数的返回值是，如果<code>&lt;condition&gt;</code>为真（非空字符串），那个<code>&lt;then-part&gt;</code>会是整个函数的返回值，如果<code>&lt;condition&gt;</code>为假（空字符串），那么<code>&lt;else-part&gt;</code>会是整个函数的返回值，此时如果<code>&lt;else-part&gt;</code>没有被定义，那么，整个函数返回空字串。</p><h3 id="7-6-call函数"><a href="#7-6-call函数" class="headerlink" title="7.6 call函数"></a>7.6 call函数</h3><p>call函数是可以创建新的参数化的函数，也是唯一一个。<br>你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以用call函数来向这个表达式传递参数。其语法是：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">call</span> &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,&lt;parm3&gt;...)</span></span><br></pre></td></tr></table></figure></p><p>当make执行这个函数时，<code>&lt;expression&gt;</code>参数中的变量，如<code>$(1)</code>，<code>$(2)</code>，<code>$(3)</code>等，会被参数<code>&lt;parm1&gt;</code>，<code>&lt;parm2&gt;</code>，<code>&lt;parm3&gt;</code>依次取代。而<code>&lt;expression&gt;</code>的返回值就是call函数的返回值。例如：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reverse =  $(1) $(2)</span><br><span class="line">foo = <span class="variable">$(<span class="built_in">call</span> reverse,a,b)</span></span><br></pre></td></tr></table></figure></p><p>那么，foo的值就是<code>a b</code>。当然，参数的次序是可以自定义的，不一定是顺序的，如：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reverse =  $(2) $(1)</span><br><span class="line">foo = <span class="variable">$(<span class="built_in">call</span> reverse,a,b)</span></span><br></pre></td></tr></table></figure></p><p>此时的foo的值就是<code>b a</code>。</p><ul><li>疑问：一定是<code>$(1)</code>、<code>$(2)</code>这种形式吗？</li></ul><h3 id="7-7-origin函数"><a href="#7-7-origin函数" class="headerlink" title="7.7 origin函数"></a>7.7 origin函数</h3><p>origin函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的？其语法是：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">origin</span> &lt;variable&gt;)</span></span><br></pre></td></tr></table></figure></p><p>注意，<code>&lt;variable&gt;</code>是变量的名字，不应该是引用。所以你最好不要在<code>&lt;variable&gt;</code>中使用<code>$</code>字符。Origin函数会以其返回值来告诉你这个变量的“出生情况”，下面，是origin函数的返回值:</p><ul><li><code>undefined</code>  <code>&lt;variable&gt;</code>从来没有定义过。</li><li><code>default</code>  <code>&lt;variable&gt;</code>是一个默认的定义，比如<code>CC</code>这个变量。</li><li><code>environment</code>  <code>&lt;variable&gt;</code>是一个环境变量，并且当Makefile被执行时，<code>-e</code>参数没有被打开。</li><li><code>file</code>  <code>&lt;variable&gt;</code>这个变量被定义在Makefile中。</li><li><code>command line</code>  <code>&lt;variable&gt;</code>这个变量是被命令行定义的。</li><li><code>override</code>  <code>&lt;variable&gt;</code>是被override指示符重新定义的。</li><li><code>automatic</code>  <code>&lt;variable&gt;</code>是一个命令运行中的自动化变量。</li></ul><p>这些信息对于我们编写Makefile是非常有用的，例如，假设我们有一个Makefile其包了一个定义文件Make.def，在Make.def中定义了一个变量<code>bletch</code>，而我们的环境中也有一个环境变量<code>bletch</code>，此时，我们想判断一下，如果变量来源于环境，那么我们就把之重定义了，如果来源于Make.def或是命令行等非环境的，那么我们就不重新定义它。于是，在我们的Makefile中，我们可以这样写：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifdef</span> bletch</span><br><span class="line">  <span class="keyword">ifeq</span> <span class="string">"$(origin bletch)"</span> <span class="string">"environment"</span></span><br><span class="line">    bletch = barf, gag, etc.</span><br><span class="line">  <span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure></p><p>与<code>override</code>对比，<code>override</code>会重新定义所有种类的变量，这种方式只会重新定义环境变量。</p><h3 id="7-8-shell函数"><a href="#7-8-shell函数" class="headerlink" title="7.8 shell函数"></a>7.8 shell函数</h3><p>shell函数也不像其它的函数。顾名思义，它的参数应该就是操作系统Shell的命令。它和反引号`是相同的功能。这就是说，shell函数把执行操作系统命令后的输出作为函数返回。于是，我们可以用操作系统命令以及字符串处理命令<code>awk</code>，<code>sed</code>等等命令来生成一个变量，如：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">contents := <span class="variable">$(<span class="built_in">shell</span> cat foo)</span></span><br><span class="line">files := <span class="variable">$(<span class="built_in">shell</span> echo *.c)</span></span><br></pre></td></tr></table></figure></p><p>注意，这个函数会新生成一个Shell程序来执行命令，所以你要注意其运行性能，如果你的Makefile中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是Makefile的隐晦的规则可能会让你的shell函数执行的次数比你想像的多得多。</p><h3 id="7-9-控制make的函数"><a href="#7-9-控制make的函数" class="headerlink" title="7.9 控制make的函数"></a>7.9 控制make的函数</h3><p>make提供了一些函数来控制make的运行。通常，你需要检测一些运行Makefile时的运行时信息，并且根据这些信息来决定，你是让make继续执行，还是停止。</p><ul><li><p><code>$(error &lt;text ...&gt;)</code></p><p>产生一个致命的错误，<code>&lt;text ...&gt;</code>是错误信息。注意，error函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也是可以的。例如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#示例一：</span></span><br><span class="line"><span class="keyword">ifdef</span> ERROR_001</span><br><span class="line"><span class="variable">$(<span class="built_in">error</span> <span class="built_in">error</span> is <span class="variable">$(ERROR_001)</span>)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例二：</span></span><br><span class="line">ERR = <span class="variable">$(<span class="built_in">error</span> found an <span class="built_in">error</span>!)</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: err</span></span><br><span class="line"><span class="section">err: ; <span class="variable">$(ERR)</span></span></span><br></pre></td></tr></table></figure><p>示例一会在变量ERROR_001定义了后执行时产生error调用，而示例二则在目录err被执行时才发生error调用。</p></li><li><p><code>(warning &lt;text ...&gt;)</code><br> 这个函数很像error函数，只是它并不会让make退出，只是输出一段警告信息，而make继续执行。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;5-使用变量&quot;&gt;&lt;a href=&quot;#5-使用变量&quot; class=&quot;headerlink&quot; title=&quot;5 使用变量&quot;&gt;&lt;/a&gt;5 使用变量&lt;/h2&gt;&lt;p&gt;在Makefile中的定义的变量，就像是C/C++语言中的宏一样，他代表了一个文本字串，在Makefile中
      
    
    </summary>
    
      <category term="教程" scheme="http://yoursite.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Makefile" scheme="http://yoursite.com/tags/Makefile/"/>
    
      <category term="编译" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Makefile学习（一）</title>
    <link href="http://yoursite.com/2018/08/17/makefile(1)/"/>
    <id>http://yoursite.com/2018/08/17/makefile(1)/</id>
    <published>2018-08-17T15:00:00.000Z</published>
    <updated>2020-05-10T07:07:14.002Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-什么是Makeflie"><a href="#0-什么是Makeflie" class="headerlink" title="0 什么是Makeflie"></a>0 什么是Makeflie</h2><h3 id="0-1-makefile关系到了整个工程的编译规则"><a href="#0-1-makefile关系到了整个工程的编译规则" class="headerlink" title="0.1 makefile关系到了整个工程的编译规则"></a>0.1 makefile关系到了整个工程的编译规则</h3><p>一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。</p><h3 id="0-2-编译的过程"><a href="#0-2-编译的过程" class="headerlink" title="0.2 编译的过程"></a>0.2 编译的过程</h3><ul><li><p>编译<br>首先编译产生目标文件(object file/.obj/.o)。编译时，编译器需要的是语法的正确，函数与变量的声明的正确。只要所有的语法正确，编译器就可以编译出中间目标文件。<br>一般来说，每个源文件都应该对应于一个中间目标文件。</p></li><li><p>链接<br>链接时，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（O文件或是OBJ文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件 (Object File) ，在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”（Library File)，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。</p></li></ul><hr><h2 id="1-Makefile介绍"><a href="#1-Makefile介绍" class="headerlink" title="1 Makefile介绍"></a>1 Makefile介绍</h2><p>示例：一个具有3个头文件和7个c文件的工程，且makefile要完成如下功能：</p><ul><li>如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。</li><li>如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。</li><li>如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。</li></ul><h3 id="1-1-Makefile规则"><a href="#1-1-Makefile规则" class="headerlink" title="1.1 Makefile规则"></a>1.1 Makefile规则</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target... : prerequisites ...</span><br><span class="line">    command</span><br></pre></td></tr></table></figure><p>target也就是一个目标文件，可以是Object File，也可以是执行文件。还可以是一个标签（Label）；</p><p>prerequisites是要生成target所需要的文件或是目标；  </p><p>command也就是make需要执行的命令。（任意的Shell命令）。</p><p>三者的关系为：target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。</p><p>进一步的：<strong>prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。</strong> 这就是Makefile的规则。也就是Makefile中最核心的内容。</p><ul><li>几个符号（自动化变量）<br>$@  –目标文件<br>$^  –所有的依赖文件<br>$&lt;  –第一个依赖文件  </li></ul><h3 id="1-2-示例"><a href="#1-2-示例" class="headerlink" title="1.2 示例"></a>1.2 示例</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一句是链接，后面是编译</span></span><br><span class="line"></span><br><span class="line">edit : main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span class="line">    cc -o edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">    cc -c main.c</span><br><span class="line"></span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">    cc -c kbd.c</span><br><span class="line"></span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">    cc -c command.c</span><br><span class="line"></span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">    cc -c display.c</span><br><span class="line"></span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">    cc -c insert.c</span><br><span class="line"></span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">    cc -c search.c</span><br><span class="line"></span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">    cc -c files.c</span><br><span class="line"></span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">    cc -c utils.c</span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">rm edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure><ul><li><p>在定义好依赖关系后，后续的那一行定义了如何生成目标文件的<strong>操作系统命令</strong>，一定要以一个<strong>Tab键作为开头</strong>。</p></li><li><p>make并不管命令是怎么工作的，他只管执行所定义的命令。</p></li><li><p>make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。</p></li><li><p><code>clean</code>是一个标签，可以用类似的方法定义命令。以此为例，只要输入<code>make clean</code>，就会执行冒号后面的命令。</p></li></ul><h3 id="1-3-make是如何工作的"><a href="#1-3-make是如何工作的" class="headerlink" title="1.3 make是如何工作的"></a>1.3 make是如何工作的</h3><p>在默认的方式下，也就是我们只输入make命令：</p><ul><li>make会在当前目录下找名字叫<code>Makefile</code>或<code>makefile</code>的文件。</li><li>如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到<code>edit</code>这个文件，并把这个文件作为最终的目标文件。</li><li>如果<code>edit</code>文件不存在，或是edit所依赖的后面的<code>.o</code>文件的文件修改时间要比<code>edit</code>这个文件新，那么，他就会执行后面所定义的命令来生成<code>edit</code>这个文件。</li><li>如果<code>edit</code>所依赖的<code>.o</code>文件也存在，那么make会在当前文件中找目标为<code>.o</code>文件的依赖性，如果找到则再根据那一个规则生成<code>.o</code>文件。（这有点像一个堆栈的过程）</li><li>当然，你的C文件和H文件是存在的啦，于是make会生成<code>.o</code>文件，然后再用<code>.o</code>文件声明make的终极任务，也就是执行文件edit了。</li></ul><p>make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性。<em>比如，如果命令不是用来编译这个目标文件的，makefile是检测不出来的</em></p><p>makefile的终极要义是依赖性：就是看目标文件的依赖文件是否都存在以及目标文件是否存在，如果目标文件存在则比较文件的生成时间，如果依赖文件不存在则递归这个编译过程，即寻找依赖文件的依赖关系，并执行这个依赖文件下的指令。</p><p>于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如file.c，那么根据我们的依赖性，我们的目标file.o会被重编译（也就是在这个依性关系后面所定义的命令），于是file.o的文件也是最新的啦，于是file.o的文件修改时间要比edit要新，所以edit也会被重新链接了（详见edit目标文件后定义的命令）。</p><h3 id="1-4-makefile中使用变量"><a href="#1-4-makefile中使用变量" class="headerlink" title="1.4 makefile中使用变量"></a>1.4 makefile中使用变量</h3><p>对于makefile中重复出现的部分，我们可以像C语言的宏一样将其定义为变量。</p><p>例如：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">cc -o edit <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 依赖关系...</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure></p><p>在指令中使用<code>$(Variable_name)</code>，即可代表一串文件的名字。</p><h3 id="1-5-让makefile自动推导"><a href="#1-5-让makefile自动推导" class="headerlink" title="1.5 让makefile自动推导"></a>1.5 让makefile自动推导</h3><p>只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中,并且 cc -c [.c] 也会被推导出来。<br>所以上述makefile语句可以简化为：  </p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">    cc -o edit <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line">main.o : defs.h</span><br><span class="line">kbd.o : defs.h command.h</span><br><span class="line">command.o : defs.h command.h</span><br><span class="line">display.o : defs.h buffer.h</span><br><span class="line">insert.o : defs.h buffer.h</span><br><span class="line">search.o : defs.h buffer.h</span><br><span class="line">files.o : defs.h buffer.h command.h</span><br><span class="line">utils.o : defs.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">    -rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure><ul><li>其中<code>.PHONY</code>表示，<code>clean</code>是个伪目标文件。</li><li>每个Makefile中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。</li><li>在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。</li></ul><h3 id="1-6-依赖关系的另一种写法"><a href="#1-6-依赖关系的另一种写法" class="headerlink" title="1.6 依赖关系的另一种写法"></a>1.6 依赖关系的另一种写法</h3><p>依赖关系可以用下列方式来写，即以被依赖的文件为主体的表达：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(objects)</span> : defs.h</span><br><span class="line">kbd.o command.o files.o : command.h</span><br><span class="line">display.o insert.o search.o files.o : buffer.h</span><br></pre></td></tr></table></figure><hr><h2 id="2-Makefile总述"><a href="#2-Makefile总述" class="headerlink" title="2 Makefile总述"></a>2 Makefile总述</h2><h3 id="2-1-Makefile里有什么"><a href="#2-1-Makefile里有什么" class="headerlink" title="2.1 Makefile里有什么"></a>2.1 Makefile里有什么</h3><p>五个部分：显式规则、隐晦规则、变量定义、文件指示和注释。</p><ul><li>显式规则<br>显式规则说明了，如何生成一个或多的的目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。</li></ul><ul><li><p>隐晦规则<br>由于make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写Makefile，这是由make所支持的。</p></li><li><p>变量定义<br>变量一般都是字符串，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。</p></li><li><p>文件指示<br>其包括了三个部分：<br>在一个Makefile中引用另一个Makefile，就像C语言中的include一样；<br>指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；<br>定义一个多行的命令。</p></li><li><p>注释<br>使用#来注释。</p></li></ul><p><strong>值得一提的是，在Makefile中的命令，必须要以[Tab]键开始。</strong></p><h3 id="2-2-Makefile的文件名"><a href="#2-2-Makefile的文件名" class="headerlink" title="2.2 Makefile的文件名"></a>2.2 Makefile的文件名</h3><p>默认的情况下，make命令会在当前目录下按顺序找寻文件名为<code>GNUmakefile</code>、<code>makefile</code>、<code>Makefile</code>的文件。最好使用<code>Makefile</code>，而不要使用<code>GNUmakefile</code>（仅适用于GNU make）。<br>也可以使用其他任意文件名，使用<code>make -f filename</code>或<code>make --file filename</code>即可调用该文件。</p><h3 id="2-3-引用其它的Makefile"><a href="#2-3-引用其它的Makefile" class="headerlink" title="2.3 引用其它的Makefile"></a>2.3 引用其它的Makefile</h3><p>使用include关键字可以把别的Makefile包含进来，这很像C语言的<code>#include</code>，被包含的文件会原模原样的放在当前文件的包含位置。</p><p>语法为：<code>include&lt;filename&gt;</code>，例如<code>include ../GNUMakeConfig/defines.qnx.mk</code>。文件路径符合当前系统shell语法即可。</p><p>在include前面可以有一些空字符，但是绝不能是[Tab]键开始。多个文件之间可以用空格隔开。<br>举个例子，你有这样几个Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量<code>$(bar)</code>，其包含了e.mk和f.mk，那么，下面的语句：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> foo.make *.mk <span class="variable">$(bar)</span></span><br></pre></td></tr></table></figure></p><p>等价于<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> foo.make a.mk b.mk c.mk e.mk f.mk</span><br></pre></td></tr></table></figure></p><p>make命令开始时，会把找寻<code>include</code>所指出的其它Makefile，并把其内容安置在当前的位置。就好像C++的<code>#include</code>指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：</p><ul><li>如果make执行时，有<code>-I</code>或<code>--include-dir</code>参数，那么make就会在这个参数所指定的目录下去寻找。</li><li>如果目录<code>/include</code>（一般是：<code>/usr/local/bin或/usr/include</code>）存在的话，make也会去找。</li></ul><p>如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。</p><h3 id="2-4-环境变量MAKEFILES"><a href="#2-4-环境变量MAKEFILES" class="headerlink" title="2.4 环境变量MAKEFILES"></a>2.4 环境变量<code>MAKEFILES</code></h3><p>如果你的当前环境中定义了环境变量<code>MAKEFILES</code>，那么，make会把这个变量中的值做一个类似于<code>include</code>的动作。这个变量中的值是其它的Makefile，用空格分隔。只是，它和<code>include</code>不同的是，从这个环境变中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理。</p><h3 id="2-5-make的工作方式"><a href="#2-5-make的工作方式" class="headerlink" title="2.5 make的工作方式"></a>2.5 make的工作方式</h3><p>GNU的make工作时的执行步骤入下：</p><ol><li>读入所有的Makefile。</li><li>读入被include的其它Makefile。</li><li>初始化文件中的变量。</li><li>推导隐晦规则，并分析所有规则。</li><li>为所有的目标文件创建依赖关系链。</li><li>根据依赖关系，决定哪些目标要重新生成。</li><li>执行生成命令。</li></ol><hr><h2 id="3-Makefile书写规则"><a href="#3-Makefile书写规则" class="headerlink" title="3 Makefile书写规则"></a>3 Makefile书写规则</h2><p>规则包含两个部分，一个是依赖关系，一个是生成目标的方法。<br>一般来说，定义在Makefile中的目标可能会有很多，但是<strong>第一条规则中的目标</strong>将被确立为<strong>最终的目标</strong>。如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。make所完成的也就是这个目标。</p><h3 id="3-1-规则的语法"><a href="#3-1-规则的语法" class="headerlink" title="3.1 规则的语法"></a>3.1 规则的语法</h3><p>如1.1和1.2节所述，规则如下所示：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main.o : main.c defs.h</span><br><span class="line">    cc -c main.c</span><br></pre></td></tr></table></figure></p><p>规则告诉我们两件事：</p><ul><li>文件的依赖关系，main.o依赖于main.c和defs.h的文件，如果main.c和defs.h的文件日期要比main.o文件日期要新，或是main.o不存在，那么依赖关系发生，执行下面的指令。</li><li>如果生成（或更新）main.o文件。也就是那个cc命令，其说明了，如何生成main.o这个文件。</li></ul><p>规则也可以写成：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.o : main.c defs.h; cc -c main.c</span><br></pre></td></tr></table></figure></p><p>命令行如果不与<code>target:prerequisites</code>在一行，那么，必须以[Tab键]开头，如果和<code>prerequisites</code>在一行，那么可以用分号做为分隔。</p><h3 id="3-2-文件搜寻"><a href="#3-2-文件搜寻" class="headerlink" title="3.2 文件搜寻"></a>3.2 文件搜寻</h3><p>在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当make需要去找寻文件的依赖关系时，可以在文件前加上路径，但最好的方法是把一个路径告诉make，让make在自动去找。</p><ul><li>特殊变量<code>VPATH</code>可以完成这个功能<br>如果没有指明<code>VPATH</code>，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">VPATH = src:../headers</span><br><span class="line">```  </span><br><span class="line">上面的的定义指定两个目录，“src”和“../headers”，make会按照这个顺序进行搜索。目录由“冒号”分隔。  </span><br><span class="line"></span><br><span class="line">* 关键字`<span class="keyword">vpath</span>`也可以设置搜索文件路径</span><br><span class="line">它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使用方法有三种：</span><br><span class="line">```makefile</span><br><span class="line"><span class="keyword">vpath</span> &lt; pattern&gt; &lt; directories&gt;    <span class="comment">#为符合模式&lt; pattern&gt;的文件指定搜索目录&lt;directories&gt;。</span></span><br><span class="line"><span class="keyword">vpath</span> &lt; pattern&gt;                   <span class="comment">#清除符合模式&lt; pattern&gt;的文件的搜索目录。</span></span><br><span class="line"><span class="keyword">vpath</span>                              <span class="comment">#清除所有已被设置好了的文件搜索目录。</span></span><br><span class="line">```  </span><br><span class="line">`vapth`使用方法中的`&lt;pattern&gt;`需要包含`%`字符。`%`的意思是匹配零或若干字符，例如，`%.h`表示所有以`.h`结尾的文件。`&lt;pattern&gt;`指定了要搜索的文件集，而`&lt;directories&gt;`则指定了的文件集的搜索的目录。例如：</span><br><span class="line">```makefile</span><br><span class="line"><span class="keyword">vpath</span> %.h ../headers</span><br></pre></td></tr></table></figure></li></ul><p>该语句表示，要求make在<code>../headers</code>目录下搜索所有以<code>.h</code>结尾的文件（如果某文件在当前目录没有找到的话）。我们可以连续地使用<code>vpath</code>语句，以指定不同搜索策略。如果连续的<code>vpath</code>语句中出现了相同的<code>&lt;pattern&gt;</code>，或是被重复了的<code>&lt;pattern&gt;</code>，那么，make会按照<code>vpath</code>语句的先后顺序来执行搜索。</p><h3 id="3-3-伪目标"><a href="#3-3-伪目标" class="headerlink" title="3.3 伪目标"></a>3.3 伪目标</h3><p>伪目标不被最终目标所依赖。比如上述的clean。我们并不生成“clean”这个文件。“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以make无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个“目标”才能让其生效。</p><p><code>.PHONY : clean</code>可以显式地声明这是一个伪目标，即使后面的名称与要编译的文件重名也没关系，<code>make clean</code>一样能够执行<code>clean</code>后的命令，这就是伪目标的特性：只要调用，无论有没有依赖关系都总是被执行。</p><p>伪目标也可以作为最终目标，也可以作为依赖：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : all</span><br><span class="line">all : prog1 prog2 prog3</span><br><span class="line"></span><br><span class="line">prog1 : prog1.o utils.o</span><br><span class="line">    cc -o prog1 prog1.o utils.o</span><br><span class="line"></span><br><span class="line">prog2 : prog2.o</span><br><span class="line">    cc -o prog2 prog2.o</span><br><span class="line"></span><br><span class="line">prog3 : prog3.o sort.o utils.o</span><br><span class="line">    cc -o prog3 prog3.o sort.o utils.o</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: cleanall cleanobj cleandiff</span></span><br><span class="line"></span><br><span class="line">cleanall : cleanobj cleandiff</span><br><span class="line">    rm program</span><br><span class="line"></span><br><span class="line">cleanobj :</span><br><span class="line">    rm *.o</span><br><span class="line"></span><br><span class="line">cleandiff :</span><br><span class="line">    rm *.diff</span><br></pre></td></tr></table></figure></p><p>对于这个makefile文件，只需要一个make命令就可以生成<code>prog1</code>、<code>prog2</code>、<code>prog3</code>三个目标，而<code>cleanall</code>依赖<code>cleanobj</code>与<code>cleandiff</code>因此使用<code>make cleanall</code>会执行所有指令。</p><h3 id="3-4-多目标"><a href="#3-4-多目标" class="headerlink" title="3.4 多目标"></a>3.4 多目标</h3><p>如1.6节所述，可以多个目标依赖一个文件：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bigoutput littleoutput : text.g</span><br><span class="line">    generate text.g -<span class="variable">$(<span class="built_in">subst</span> output,,<span class="variable">$@</span>)</span> &gt; <span class="variable">$@</span></span><br></pre></td></tr></table></figure></p><p>上述规则等价于：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bigoutput : text.g</span><br><span class="line">    generate text.g -big &gt; bigoutput</span><br><span class="line"></span><br><span class="line">littleoutput : text.g</span><br><span class="line">    generate text.g -little &gt; littleoutput</span><br></pre></td></tr></table></figure></p><h3 id="3-5-静态模式"><a href="#3-5-静态模式" class="headerlink" title="3.5 静态模式"></a>3.5 静态模式</h3><p>静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。<br>其语法为：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;targets...&gt;: &lt;target-pattern&gt;: &lt;prereq-patterns ...&gt;</span></span><br><span class="line">    &lt;commands&gt;</span><br></pre></td></tr></table></figure></p><p><code>&lt;targets&gt;</code>定义了一系列的目标文件，可以有通配符。是目标的一个集合。<br><code>&lt;target-parrtern&gt;</code>是指明了<code>&lt;targets&gt;</code>的模式，也就是的目标集模式。<br><code>&lt;prereq-parrterns&gt;</code>是目标的依赖模式，它对<code>&lt;target-parrtern&gt;</code>形成的模式再进行一次依赖目标的定义。</p><p>如果我们的<code>&lt;target-parrtern&gt;</code>定义成<code>%.o</code>，意思是我们的集合中都是以<code>.o</code>结尾的，而如果我们的<code>&lt;prereq-parrterns&gt;</code>定义成<code>%.c</code>，意思是对<code>&lt;target-parrtern&gt;</code>所形成的目标集进行二次定义，其计算方法是，取<code>&lt;target-parrtern&gt;</code>模式中的<code>%</code>（也就是去掉了<code>.o</code>这个结尾），并为其加上<code>.c</code>这个结尾，形成的新集合。</p><p>举例来说：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">objects = foo.o bar.o</span><br><span class="line"><span class="section">all: <span class="variable">$(objects)</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(objects)</span>: %.o: %.c</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure></p><p>其相当于<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo.o : foo.c</span><br><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> foo.c -o foo.o</span><br><span class="line"></span><br><span class="line">bar.o : bar.c</span><br><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> bar.c -o bar.o</span><br></pre></td></tr></table></figure></p><p>再比如：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">files = foo.elc bar.o lose.o</span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span> %.o,<span class="variable">$(files)</span>)</span>: %.o: %.c</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span> %.elc,<span class="variable">$(files)</span>)</span>: %.elc: %.el</span><br><span class="line">    emacs -f batch-byte-compile <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure></p><h3 id="3-6-自动生成依赖性"><a href="#3-6-自动生成依赖性" class="headerlink" title="3.6 自动生成依赖性"></a>3.6 自动生成依赖性</h3><p>使用<code>gcc -MM filename</code>或<code>cc -m filename</code>可以输出文件的依赖项。<br>GNU组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个<code>name.c</code>的文件都生成一个<code>name.d</code>的Makefile文件，<code>.d</code>文件中就存放对应<code>.c</code>文件的依赖关系。<br>于是，我们可以写出<code>.c</code>文件和<code>.d</code>文件的依赖关系，并让make自动更新或自成<code>.d</code>文件，并把其包含在我们的主Makefile中，这样，我们就可以自动化地生成每个文件的依赖关系了。</p><p>这里，我们给出了一个模式规则来产生[.d]文件：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">%.d: %.c</span></span><br><span class="line">    @set -e; rm -f <span class="variable">$@</span>; \</span><br><span class="line">    <span class="variable">$(CC)</span> -M <span class="variable">$(CPPFLAGS)</span> <span class="variable">$&lt;</span> &gt;; <span class="variable">$@</span>.$$$$; \</span><br><span class="line">    sed 's,\(<span class="variable">$*</span>\)\.o[ :]*,\1.o <span class="variable">$@</span> : ,g' &lt; <span class="variable">$@</span>.$$$$ &gt;; <span class="variable">$@</span>; \</span><br><span class="line">    rm -f <span class="variable">$@</span>.$$$$</span><br></pre></td></tr></table></figure></p><p>这个规则的意思是，所有的<code>.d</code>文件依赖于<code>.c</code>文件，<code>rm -f $@</code>的意思是删除所有的目标，也就是<code>.d</code>文件，第二行的意思是，为每个依赖文件<code>$&lt;</code>，也就是<code>.c</code>文件生成依赖文件，<code>$@</code>表示模式 <code>%.d</code>文件，如果有一个C文件是name.c，那么<code>%</code>就是<code>name</code>，<code>$$$$</code>意为一个随机编号，第二行生成的文件有可能是 <code>name.d.12345</code>，第三行使用<code>sed</code>命令做了一个替换，关于<code>sed</code>命令的用法请参看相关的使用文档。第四行就是删除临时文件。</p><p>总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入[.d]文件的依赖，即把依赖关系：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.o : main.c defs.h</span><br></pre></td></tr></table></figure></p><p>转成：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.o main.d : main.c defs.h</span><br></pre></td></tr></table></figure></p><p>接下来，我们就要把这些自动生成的规则放进我们的主Makefile中。我们可以使用 Makefile的<code>include</code>命令，来引入别的Makefile文件，例如：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sources = foo.c bar.c</span><br><span class="line"><span class="keyword">include</span> $(sources:.c=.d)</span><br></pre></td></tr></table></figure></p><p>上述语句中的<code>$(sources:.c=.d)</code>中的“.c=.d”的意思是做一个替换，把变量<code>$(sources)</code>所有<code>.c</code>的字串都替换成<code>.d</code>，关于这个“替换”的内容，在后面我会有更为详细的讲述。当然，你得注意次序，因为<code>include</code>是按次来载入文件，最先载入的<code>.d</code>文件中的 目标会成为默认目标。</p><hr><h2 id="4-Makefile书写命令"><a href="#4-Makefile书写命令" class="headerlink" title="4 Makefile书写命令"></a>4 Makefile书写命令</h2><h3 id="4-1-显示命令"><a href="#4-1-显示命令" class="headerlink" title="4.1 显示命令"></a>4.1 显示命令</h3><p>通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用“@”字符在命令行前，那么，这个命令将不被make显示出来，最具代表性的例子是，我们用这个功能来像屏幕显示一些信息。如：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@echo 正在编译XXX模块......</span><br></pre></td></tr></table></figure></p><p>当make执行时，会输出“正在编译XXX模块……”字串，但不会输出命令，如果没有“@”，那么，make将输出：</p><p>echo 正在编译XXX模块……<br>正在编译XXX模块……</p><p>如果make执行时，带入make参数<code>-n</code>或<code>--just-print</code>，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。</p><p>而make参数<code>-s</code>或<code>--slient</code>则是全面禁止命令的显示。</p><h3 id="4-2-命令执行"><a href="#4-2-命令执行" class="headerlink" title="4.2 命令执行"></a>4.2 命令执行</h3><p>当依赖目标新于目标时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。<br>需要注意的是，如果要让<strong>上一条命令的结果应用在下一条命令时，应该使用分号分隔这两条命令</strong>。比如第一条命令是<code>cd</code>命令，你希望第二条命令得在<code>cd</code>之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。如：</p><p>示例一：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">exec:</span></span><br><span class="line">    cd /home/hchen</span><br><span class="line">    pwd</span><br></pre></td></tr></table></figure></p><p>示例二：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">exec:</span></span><br><span class="line">    cd /home/hchen; pwd</span><br></pre></td></tr></table></figure></p><p>当我们执行<code>make exec</code>时，第一个例子中的<code>cd</code>没有作用，<code>pwd</code>会打印出当前的Makefile目录，而第二个例子中，<code>cd</code>就起作用了，pwd会打印出<code>/home/hchen</code>。</p><h3 id="4-3-命令出错"><a href="#4-3-命令出错" class="headerlink" title="4.3 命令出错"></a>4.3 命令出错</h3><p>每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。</p><p>有时命令返回非0并不代表有错误，比如<code>mkdir</code>的目录已存在。此时，我们在命令前加<code>-</code>，标记为不管命令出不出错都认为是成功的。</p><p>另一种方式为给make加上<code>-i</code>或是<code>--ignore-errors</code>参数，那么，Makefile中所有命令都会忽略错误。而如果一个 规则是以<code>.IGNORE</code>作为目标的，那么这个规则中的所有命令将会忽略错误。</p><p>还有一个要提一下的make的参数的是<code>-k</code>或是<code>--keep-going</code>，这个参数的意思是，如果某规则中的命令出错了，那么就终目该规则的执行，但继续执行其它规则。</p><h3 id="4-4-嵌套执行make"><a href="#4-4-嵌套执行make" class="headerlink" title="4.4 嵌套执行make"></a>4.4 嵌套执行make</h3><p>在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的Makefile，这有利于让我们的Makefile变得更加地简洁，而不至于把所有的东西全部写在一个Makefile中，这样会很难维护我们的Makefile，这个技术对于我们模 块编译和分段编译有着非常大的好处。</p><p>例如，我们有一个子目录叫<code>subdir</code>，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么我们总控的Makefile可以这样书写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subsystem:</span><br><span class="line">    cd subdir &amp;&amp; $(MAKE)</span><br></pre></td></tr></table></figure><p>其等价于：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C subdir</span><br></pre></td></tr></table></figure></p><p>定义<code>$(MAKE)</code>宏变量的意思是，也许我们的make需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入<code>subdir</code>目录，然后执行make命令。<br>我们把这个Makefile叫做“总控Makefile”，总控Makefile的变量可以传递到下级的Makefile中（如果你显示的声明），但是不会覆盖下层的Makefile中所定义的变量，除非指定了<code>-e</code>参数。</p><p>如果你要传递变量到下级Makefile中，那么你可以使用这样的声明：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &lt;variable ...&gt;;</span><br></pre></td></tr></table></figure></p><p>如果你不想让某些变量传递到下级Makefile中，那么你可以这样声明：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unexport</span> &lt;variable ...&gt;;</span><br></pre></td></tr></table></figure></p><p>示例：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#示例一</span></span><br><span class="line"><span class="keyword">export</span> variable = value</span><br><span class="line"><span class="comment">#其等价于：</span></span><br><span class="line">variable = value</span><br><span class="line"><span class="keyword">export</span> variable</span><br><span class="line"><span class="comment">#其等价于：</span></span><br><span class="line"><span class="keyword">export</span> variable := value</span><br><span class="line"><span class="comment">#其等价于：</span></span><br><span class="line">variable := value</span><br><span class="line"><span class="keyword">export</span> variable</span><br><span class="line"><span class="comment">#示例二：</span></span><br><span class="line"><span class="keyword">export</span> variable += value</span><br><span class="line"><span class="comment">#其等价于：</span></span><br><span class="line">variable += value</span><br><span class="line"><span class="keyword">export</span> variable</span><br></pre></td></tr></table></figure></p><p>如果你要传递所有的变量，那么，只要一个<code>export</code>就行了。后面什么也不用跟，表示传递所有的变量。</p><p>需要注意的是，有两个变量，一个是<code>SHELL</code>，一个是<code>MAKEFLAGS</code>，这两个变量不管你是否<code>export</code>，其总是要传递到下层Makefile中，特别是<code>MAKEFILES</code>变量，其中包含了make的参数信息，如果我们执行“总控Makefile”时有make参数或是在上层Makefile中定义了 这个变量，那么<code>MAKEFILES</code>变量将会是这些参数，并会传递到下层Makefile中，这是一个系统级的环境变量。</p><h3 id="4-5-定义命令包"><a href="#4-5-定义命令包" class="headerlink" title="4.5 定义命令包"></a>4.5 定义命令包</h3><p>如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以<code>define</code>开始，以<code>endef</code>结束，如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> run-yacc</span><br><span class="line">yacc <span class="variable">$(<span class="built_in">firstword</span> <span class="variable">$^</span>)</span></span><br><span class="line">mv y.tab.c <span class="variable">$@</span></span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用命令包</span></span><br><span class="line">foo.c : foo.y</span><br><span class="line">    $(run-yacc)</span><br></pre></td></tr></table></figure><p>这里，<code>run-yacc</code>是这个命令包的名字，其不要和Makefile中的变量重名。在<code>define</code>和<code>endef</code>中的两行就是命令序列。这个命令包中的第一个命令是运行<code>Yacc</code>程序，因为<code>Yacc</code>程序总是生成<code>y.tab.c</code>的文件，所以第二行的命令就是把这个文件改改名字。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0-什么是Makeflie&quot;&gt;&lt;a href=&quot;#0-什么是Makeflie&quot; class=&quot;headerlink&quot; title=&quot;0 什么是Makeflie&quot;&gt;&lt;/a&gt;0 什么是Makeflie&lt;/h2&gt;&lt;h3 id=&quot;0-1-makefile关系到了整个工程的
      
    
    </summary>
    
      <category term="教程" scheme="http://yoursite.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Makefile" scheme="http://yoursite.com/tags/Makefile/"/>
    
      <category term="编译" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>C++类零碎</title>
    <link href="http://yoursite.com/2018/07/29/C++%E7%B1%BB%E9%9B%B6%E7%A2%8E/"/>
    <id>http://yoursite.com/2018/07/29/C++类零碎/</id>
    <published>2018-07-28T22:00:00.000Z</published>
    <updated>2020-05-10T07:05:43.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="私有构造函数"><a href="#私有构造函数" class="headerlink" title="私有构造函数"></a>私有构造函数</h2><p>首先，private成员与方法只能被类内部的方法访问，而protected成员与方法只能被类内部或派生类内部的方法访问。<br>而构造函数一定是在外部被访问，所以含有private或protected构造函数的类不能声明对象。<br>我觉得这种类常用于抽象类，即含有纯虚函数的类，这种类用于实现多态，只能从其子类声明对象，为了防止用抽象类声明对象，将其构造函数设为私有。</p><ul><li><p>派生类的构造函数调用</p><p>既然抽象类不能声明对象，那么其构造函数还有什么意义呢？<br>回忆起子类声明的过程，构造函数是一层层向上调用的，所以最终会调用抽象基类的构造函数，用来初始化抽象基类的成员。</p></li><li><p>单例模式</p><p>private构造函数还有一个重要的用法为实现简单单例模式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSingleton</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  CSingleton()&#123;<span class="comment">//构造函数是私有的</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> CSingleton *m_pInstance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> CSingleton * <span class="title">GetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(m_pInstance == <span class="literal">NULL</span>)  <span class="comment">//判断是否第一次调用</span></span><br><span class="line">m_pInstance = <span class="keyword">new</span> CSingleton();</span><br><span class="line"><span class="keyword">return</span> m_pInstance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用户获得实例的方法只有通过<code>GetInstance</code>方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CSingleton * pCSingle = CSingleton::GetInstance();</span><br><span class="line">CSingleton * p2 = pCSingle-&gt;GetInstance();</span><br></pre></td></tr></table></figure></li></ul><h2 id="类的static成员"><a href="#类的static成员" class="headerlink" title="类的static成员"></a>类的<code>static</code>成员</h2><p>首先，<code>static</code>关键字的作用有二：</p><ul><li>当它用在全局变量上时，它的作用是限制该变量的可见范围，将该变量限制在本文件内可见；</li><li>当它应用在局部变量上时，会将该变量的存储位置改变为存储在静态区，并且将该变量的生存周期改为整个程序都存在，虽然变量的作用域不发生变化。</li></ul><p>类中定义的<code>static</code>成员，同样存储在静态存储区，类的所有对象共用<code>static</code>成员，既保证了对外部隐藏，即作用于仅限于类内部，又实现了所有类对象之间的共享。</p><ul><li>对于<code>static</code>函数，其没有this指针，不能访问类的普通成员与成员函数，只能访问类的静态成员；</li><li>对于<code>static</code>成员，需要在定义时初始化，且不能在头文件中初始化，初始化方法为：<code>&lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt;=&lt;值&gt;</code>；</li><li>对于<code>public</code>类型的<code>static</code>成员，可用<code>&lt;类名&gt;::&lt;静态成员名&gt;</code>的方法在非类的对象中引用静态成员，进一步说明了静态成员属于类而非对象；</li><li>子类和父类的同名<code>static</code>成员或方法，调用哪一个看作用域。</li></ul><h2 id="虚函数调用"><a href="#虚函数调用" class="headerlink" title="虚函数调用"></a>虚函数调用</h2><p>今天对虚函数的调用有疑问，主要疑问为：类方法对虚函数的调用到底调用的是哪个。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">go_out</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"out A"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">go_out();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">go_out</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"out B"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">go_out</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"out C"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">C *cc = <span class="keyword">new</span> C();</span><br><span class="line">cc-&gt;test();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实验发现，输出结果为<code>out C</code>。<br>其实这符合虚函数的调用原理，毕竟test是通过指向C类型的指针调用的。<br>改为<code>B *cc = new C();</code>输出结果也一样。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;私有构造函数&quot;&gt;&lt;a href=&quot;#私有构造函数&quot; class=&quot;headerlink&quot; title=&quot;私有构造函数&quot;&gt;&lt;/a&gt;私有构造函数&lt;/h2&gt;&lt;p&gt;首先，private成员与方法只能被类内部的方法访问，而protected成员与方法只能被类内部或派生类内部
      
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="多态" scheme="http://yoursite.com/tags/%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>typedef与函数指针</title>
    <link href="http://yoursite.com/2018/07/26/typedef%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"/>
    <id>http://yoursite.com/2018/07/26/typedef函数指针/</id>
    <published>2018-07-25T22:44:00.000Z</published>
    <updated>2020-05-10T07:08:45.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="typedef基本"><a href="#typedef基本" class="headerlink" title="typedef基本"></a>typedef基本</h2><p>今日在代码中看到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(ISSCALLBACK *Proc_MVWOnMsgProc)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">void</span>*         pUsrArg,     <span class="comment">/* [In] User defined parameter */</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        uMsg,        <span class="comment">/* [In] The message identifier */</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        wParam,      <span class="comment">/* [In] Message additional information */</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">void</span>*         lParam        <span class="comment">/* [In] Message additional information */</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>一时之间无法理解其意义，发觉自己对<code>typedef</code>以及函数指针有些生疏，现在重新整理二者用法。</p><p>首先看一个变量定义与<code>typedef</code>的区别：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> number1;<span class="comment">//number为 unsigned int 型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> number2;<span class="comment">//使用number2定义的变量为 unsigned int 型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> ISS_TTS_CODEPAGE &#123;</span><br><span class="line">    ISS_TTS_CODEPAGE_GBK = <span class="number">936</span>,</span><br><span class="line">    ISS_TTS_CODEPAGE_UTF16LE = <span class="number">1200</span>,</span><br><span class="line">    ISS_TTS_CODEPAGE_UTF8 = <span class="number">65001</span></span><br><span class="line">&#125; ISSTTSCodePage;</span><br><span class="line"><span class="comment">//ISSTTSCodePage为ISS_TTS_CODEPAGE类型的enum</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> ISS_TTS_CODEPAGE &#123;</span><br><span class="line">    ISS_TTS_CODEPAGE_GBK = <span class="number">936</span>,</span><br><span class="line">    ISS_TTS_CODEPAGE_UTF16LE = <span class="number">1200</span>,</span><br><span class="line">    ISS_TTS_CODEPAGE_UTF8 = <span class="number">65001</span></span><br><span class="line">&#125; ISSTTSCodePage2;</span><br><span class="line"><span class="comment">//ISSTTSCodePage定义的变量为ISS_TTS_CODEPAGE类型的enum</span></span><br><span class="line">ISSTTSCodePage2 someitem;</span><br></pre></td></tr></table></figure><p>可以看出原有的定义加上<code>typedef</code>就将其转化为定义原定义的类型。</p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>再来说函数指针，举最简单的例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> (*PTRFUN)(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure></p><p>表示<code>PTRFUN</code>指向一个形参为<code>int</code>返回值为<code>char</code>的函数</p><p>若是加上<code>typedef</code>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">char</span> <span class="params">(*PTRFUN)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure></p><p>则可以用<code>PTRFUN</code>来定义函数，特别是用在回调函数上：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">callbackfunc</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">bool</span> torf, PTRFUN somefunc)</span></span>;</span><br></pre></td></tr></table></figure></p><h2 id="typedef数组指针"><a href="#typedef数组指针" class="headerlink" title="typedef数组指针"></a>typedef数组指针</h2><p>今天又在代码中看到：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE (3200)</span></span><br><span class="line"><span class="keyword">typedef</span> byte BUFFER[BUFSIZE];</span><br><span class="line">BUFFER *m_pBuffer = <span class="keyword">new</span> BUFFER[BUFNUM];</span><br></pre></td></tr></table></figure></p><p>有点迷惑<code>new</code>出来的是<code>byte[10][3200]</code>还是<code>byte[3200][10]</code>。<br>其实看<code>m_pBuffer</code>的类型即可，将<code>*m_pBuffer</code>替换到typedef定义中，即是：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte *m_pBuffer[BUFSIZE];</span><br></pre></td></tr></table></figure></p><p>即<code>m_pBuffer</code>为指向<code>byte[3200]</code>的指针，可见new出来的一定是<code>byte[10][3200]</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;typedef基本&quot;&gt;&lt;a href=&quot;#typedef基本&quot; class=&quot;headerlink&quot; title=&quot;typedef基本&quot;&gt;&lt;/a&gt;typedef基本&lt;/h2&gt;&lt;p&gt;今日在代码中看到：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp
      
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu安装后要做的一些事</title>
    <link href="http://yoursite.com/2017/11/06/ubuntu%E5%AE%89%E8%A3%85%E5%90%8E%E8%A6%81%E5%81%9A%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/"/>
    <id>http://yoursite.com/2017/11/06/ubuntu安装后要做的一些事/</id>
    <published>2017-11-05T22:00:00.000Z</published>
    <updated>2020-05-10T07:09:19.679Z</updated>
    
    <content type="html"><![CDATA[<p>ubuntu我重装了不知道有多少遍，每次重装时都要重复进行一些操作，这次干脆将这些常用操作记录下来，以便下次重装时查询。</p><hr><h2 id="更换软件源"><a href="#更换软件源" class="headerlink" title="更换软件源"></a>更换软件源</h2><ul><li><p>编辑源  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gedit /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>  将原内容更换为：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb https://linux.xidian.edu.cn/mirrors/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line">deb https://linux.xidian.edu.cn/mirrors/ xenial-security main restricted universe multiverse</span><br><span class="line">deb https://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line">deb https://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-proposed main restricted universe multiverse</span><br><span class="line">deb https://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">deb-src https://linux.xidian.edu.cn/mirrors/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line">deb-src https://linux.xidian.edu.cn/mirrors/ xenial-security main restricted universe multiverse</span><br><span class="line">deb-src https://linux.xidian.edu.cn/mirrors/ xenial-updates main restricted universe multiverse</span><br><span class="line">deb-src https://linux.xidian.edu.cn/mirrors/ xenial-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://linux.xidian.edu.cn/mirrors/ xenial-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>  这里要感谢<a href="https://linux.xidian.edu.cn/" target="_blank" rel="noopener">西电开源社区</a>的无私奉献，让我们在校内能够享受速度快且免流的软件源。</p></li><li><p>更新源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt update</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="翻墙"><a href="#翻墙" class="headerlink" title="翻墙"></a>翻墙</h2><blockquote><p>不翻墙，毋宁死。</p></blockquote><ul><li><p>安装miredo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install miredo</span><br></pre></td></tr></table></figure></li><li><p>测试是否有ipv6连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ping6 ipv6.baidu.com</span><br></pre></td></tr></table></figure><p>  但每次开机都需要重新启动miredo，非常麻烦，所以在<code>/etc/local.rc</code>文件中添加<code>/etc/init.d/miredo start</code>使miredo开机自启，注意要添加在<code>exit 0</code>之前。</p></li><li><p>安装ss</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository ppa:hzwhuang/ss-qt5</span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install shadowsocks-qt5</span><br></pre></td></tr></table></figure></li><li><p>配置chrome<br>在ss配置完毕后，以代理模式打开chrome：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ google-chrome --proxy-server=socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure><p>  登录google帐号，同步插件与书签，并导入proxy配置。</p></li></ul><hr><h2 id="安装rEFInd"><a href="#安装rEFInd" class="headerlink" title="安装rEFInd"></a>安装rEFInd</h2><p>双系统用grub引导可以说是非常丑，紫不拉叽的背景，无法更改的界面。于是选择<a href="http://www.rodsbooks.com/refind/installing.html" target="_blank" rel="noopener">rEFInd</a>作为双系统的引导。  </p><ul><li><p>安装:<br>执行脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./refind-install</span><br></pre></td></tr></table></figure><p>  或者使用apt安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-add-repository ppa:rodsmith/refind</span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install refind</span><br></pre></td></tr></table></figure><p>  安装后路径为：<code>/boot/efi/EFI/refind</code></p></li><li><p>安装主题<br><code>/boot/efi/EFI/refind</code>目录下新建themes文件夹，并将rEFInd-minimal文件夹复制进去。<br>将代码<code>include themes/rEFInd-minimal/theme.conf</code>添加到<code>refind.conf</code>文件末尾。<br>更改下面几个选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">timeout 2             <span class="comment">#超时</span></span><br><span class="line">resolution 1920 1080  <span class="comment">#分辨率</span></span><br><span class="line">max_tags 3            <span class="comment">#最大图标个数</span></span><br></pre></td></tr></table></figure></li><li><p>跳过grub引导<br>将文件<code>/etc/default/grub</code>中的<code>#GRUB_HIDDEN_TIMEOUT=0</code>注释去掉，就会跳过grub引导，直接进入系统。</p></li></ul><hr><h2 id="解决ubuntu-windows时间不一致的问题"><a href="#解决ubuntu-windows时间不一致的问题" class="headerlink" title="解决ubuntu/windows时间不一致的问题"></a>解决ubuntu/windows时间不一致的问题</h2><ul><li>一行指令搞定<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ timedatectl <span class="built_in">set</span>-local-rtc 1 --adjust-system-clock</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="安装unity主题"><a href="#安装unity主题" class="headerlink" title="安装unity主题"></a>安装unity主题</h2><p>unity有许多类mac主题与扁平化图标，这里选择Flatabulous主题与ultra-flat图标。</p><ul><li><p>unity-tweak-tool<br>首先安装unity-tweak-tool，管理主题与图标，并进行一些unity的设置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install unity-tweak-tool</span><br></pre></td></tr></table></figure></li><li><p>Flatabulous主题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository ppa:noobslab/themes</span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install flatabulous-theme</span><br></pre></td></tr></table></figure></li><li><p>ultra-flat图标</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository ppa:noobslab/icons</span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install ultra-flat-icons</span><br></pre></td></tr></table></figure><p>  效果如下：<br><img src="/img/xiaoguo.png" alt>  </p></li></ul><hr><h2 id="常用软件安装"><a href="#常用软件安装" class="headerlink" title="常用软件安装"></a>常用软件安装</h2><blockquote><p>linux下自然是用来学习与写代码的，下面这几个常用软件也是必装的。</p></blockquote><ul><li><p>sublime text</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装GPG key</span></span><br><span class="line">$ wget -qO - https://download.sublimetext.com/sublimehq-pub.gpg | sudo apt-key add -</span><br><span class="line"><span class="comment">#确保apt工作在https源的模式</span></span><br><span class="line">$ sudo apt-get install apt-transport-https</span><br><span class="line"><span class="comment">#使用stable方式安装</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"deb https://download.sublimetext.com/ apt/stable/"</span> | sudo tee</span><br><span class="line">$ /etc/apt/sources.list.d/sublime-text.list</span><br><span class="line"><span class="comment">#更新源并安装</span></span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install sublime-text</span><br></pre></td></tr></table></figure></li><li><p>spyder</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt install spyder</span><br></pre></td></tr></table></figure></li><li><p>mysql</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#第一条指令安装过程中需要设定root密码</span></span><br><span class="line">$ sudo apt install mysql-server</span><br><span class="line">$ sudo apt install mysql-client</span><br><span class="line">$ sudo apt install libmysqlclient-dev</span><br><span class="line"><span class="comment">#可视化工具</span></span><br><span class="line">$ sudo apt install mysql-workbench</span><br></pre></td></tr></table></figure></li><li><p>wps<br>unbuntu自带的libre与MS office之间有许多兼容性问题，所以卸载libre，安装wps。<br>卸载libre：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get remove libreoffice-common</span><br></pre></td></tr></table></figure><p>  安装完wps后会有字体缺失问题，下载<a href="https://pan.baidu.com/s/1eS6xIzo" target="_blank" rel="noopener">字体文件</a>，将目录中所有文件复制到<code>/usr/share/fonts</code>下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cp mtextra.ttf  symbol.ttf  WEBDINGS.TTF  wingding.ttf  WINGDNG2.ttf  WINGDNG3.ttf  /usr/share/fonts</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ubuntu我重装了不知道有多少遍，每次重装时都要重复进行一些操作，这次干脆将这些常用操作记录下来，以便下次重装时查询。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;更换软件源&quot;&gt;&lt;a href=&quot;#更换软件源&quot; class=&quot;headerlink&quot; title=&quot;更换软件源&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="记录" scheme="http://yoursite.com/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>seafile部署记录</title>
    <link href="http://yoursite.com/2017/11/04/2017-11-03-seafile/"/>
    <id>http://yoursite.com/2017/11/04/2017-11-03-seafile/</id>
    <published>2017-11-03T17:23:35.000Z</published>
    <updated>2020-05-10T07:04:54.901Z</updated>
    
    <content type="html"><![CDATA[<p>近日在网上看到vps可以部署私有云存储，正好手头上的vps除了SS搭梯子没有别的用途，遂在网上寻找云存储搭建教程。最后决定使用<a href="&quot;https://www.xiaoz.me/archives/8480&quot;">xiaoz</a>的一键搭建脚本。  </p><h3 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h3><ul><li>CenOS 7 64位  </li><li>Python &gt;= 2.7</li><li>SqLite 3  </li></ul><hr><h3 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h3><p>输入以下命令以进行安装  </p><pre><code class="bash">$ yum -y install wget  $ wget https://raw.githubusercontent.com/helloxz/seafile/<span class="variable">$master</span>/install_seafile.sh  $ chmod +x install_seafile.sh &amp;&amp; ./install_seafile.sh</code></pre><blockquote><p>其中最后一条命令可以用于卸载。</p></blockquote><p>安装过程跟着脚本走就可以，注意填写<em>server’s ip or domain</em>时不要瞎填，填自己vps的公网ip即可。<br>安装完成后使用<code>http://公网ip:8000</code>进行访问。</p><hr><h3 id="维护相关"><a href="#维护相关" class="headerlink" title="维护相关"></a>维护相关</h3><p>官方帮助文档：<a href="https://manual-cn.seafile.com/" target="_blank" rel="noopener">https://manual-cn.seafile.com/</a><br>客户端下载：<a href="https://www.seafile.com/download/" target="_blank" rel="noopener">https://www.seafile.com/download/</a>  </p><p>使用以下命令维护：</p><pre><code class="bash"><span class="comment">#安装目录  </span>/home/MyCloud  <span class="comment">#启动服务  </span>/home/MyCloud/seafile-server/seafile.sh start  /home/MyCloud/seafile-server/seahub.sh start  <span class="comment">#停止服务  </span>/home/MyCloud/seafile-server/seafile.sh stop  /home/MyCloud/seafile-server/seahub.sh stop  <span class="comment">#重置管理员账号   </span>/home/MyCloud/seafile-server/reset-admin.sh</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;近日在网上看到vps可以部署私有云存储，正好手头上的vps除了SS搭梯子没有别的用途，遂在网上寻找云存储搭建教程。最后决定使用&lt;a href=&quot;&amp;quot;https://www.xiaoz.me/archives/8480&amp;quot;&quot;&gt;xiaoz&lt;/a&gt;的一键搭建脚本。
      
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/11/03/hello-world/"/>
    <id>http://yoursite.com/2017/11/03/hello-world/</id>
    <published>2017-11-03T12:00:00.000Z</published>
    <updated>2020-05-10T07:03:31.104Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开坑感言"><a href="#开坑感言" class="headerlink" title="开坑感言"></a>开坑感言</h3><p>终于在拖延了这么久之后，用了两个晚上和一个下午把这个博客搭建起来。  </p><p>其实之前并没有写博客的习惯，但经常有一些事情，还是希望记录下来。有时有些想法转瞬即逝，但却没有及时抓住，过几日就忘得差不多了；有些脚本、代码或者方法，不记录下来，等再次遇到又要求助于百度，实在是麻烦；一本书看毕，无论是小说还是技术书籍，总有些收获，也能写上一两篇文章。  </p><p>本博客托管于github，其实基本不会有什么人来访问（<em>因为我github就没怎么用过</em>），主要就是记录给自己看，相当于一个云笔记了。<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo</a>的主题还是很给力的，非常美观，自定义程度高，多少也能接触一些前端技术。正文使用<a href="http://wowubuntu.com/markdown/" target="_blank" rel="noopener">markdown</a>编写，省力又有趣，何乐而不为。</p><p>总之，第一篇博客测试的成分居多，就这样吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;开坑感言&quot;&gt;&lt;a href=&quot;#开坑感言&quot; class=&quot;headerlink&quot; title=&quot;开坑感言&quot;&gt;&lt;/a&gt;开坑感言&lt;/h3&gt;&lt;p&gt;终于在拖延了这么久之后，用了两个晚上和一个下午把这个博客搭建起来。  &lt;/p&gt;
&lt;p&gt;其实之前并没有写博客的习惯，但经常有一
      
    
    </summary>
    
      <category term="闲聊" scheme="http://yoursite.com/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="想法" scheme="http://yoursite.com/tags/%E6%83%B3%E6%B3%95/"/>
    
  </entry>
  
</feed>
