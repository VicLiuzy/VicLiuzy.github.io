<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>What happened</title>
  
  <subtitle>hello world</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-29T02:08:35.855Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Vic Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++类零碎</title>
    <link href="http://yoursite.com/2018/07/29/C++%E7%B1%BB%E9%9B%B6%E7%A2%8E/"/>
    <id>http://yoursite.com/2018/07/29/C++类零碎/</id>
    <published>2018-07-28T22:00:00.000Z</published>
    <updated>2018-07-29T02:08:35.855Z</updated>
    
    <content type="html"><![CDATA[<h2 id="私有构造函数"><a href="#私有构造函数" class="headerlink" title="私有构造函数"></a>私有构造函数</h2><p>首先，private成员与方法只能被类内部的方法访问，而protected成员与方法只能被类内部或派生类内部的方法访问。<br>而构造函数一定是在外部被访问，所以含有private或protected构造函数的类不能声明对象。<br>我觉得这种类常用于抽象类，即含有纯虚函数的类，这种类用于实现多态，只能从其子类声明对象，为了防止用抽象类声明对象，将其构造函数设为私有。</p><ul><li><p>派生类的构造函数调用</p><p>既然抽象类不能声明对象，那么其构造函数还有什么意义呢？<br>回忆起子类声明的过程，构造函数是一层层向上调用的，所以最终会调用抽象基类的构造函数，用来初始化抽象基类的成员。</p></li><li><p>单例模式</p><p>private构造函数还有一个重要的用法为实现简单单例模式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSingleton</span>&#123;</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  CSingleton()&#123;<span class="comment">//构造函数是私有的</span></div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">static</span> CSingleton *m_pInstance;</div><div class="line"><span class="keyword">public</span>:</div><div class="line"><span class="function"><span class="keyword">static</span> CSingleton * <span class="title">GetInstance</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(m_pInstance == <span class="literal">NULL</span>)  <span class="comment">//判断是否第一次调用</span></div><div class="line">m_pInstance = <span class="keyword">new</span> CSingleton();</div><div class="line"><span class="keyword">return</span> m_pInstance;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>用户获得实例的方法只有通过<code>GetInstance</code>方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CSingleton * pCSingle = CSingleton::GetInstance();</div><div class="line">CSingleton * p2 = pCSingle-&gt;GetInstance();</div></pre></td></tr></table></figure></li></ul><h2 id="类的static成员"><a href="#类的static成员" class="headerlink" title="类的static成员"></a>类的<code>static</code>成员</h2><p>首先，<code>static</code>关键字的作用有二：</p><ul><li>当它用在全局变量上时，它的作用是限制该变量的可见范围，将该变量限制在本文件内可见；</li><li>当它应用在局部变量上时，会将该变量的存储位置改变为存储在静态区，并且将该变量的生存周期改为整个程序都存在，虽然变量的作用域不发生变化。</li></ul><p>类中定义的<code>static</code>成员，同样存储在静态存储区，类的所有对象共用<code>static</code>成员，既保证了对外部隐藏，即作用于仅限于类内部，又实现了所有类对象之间的共享。</p><ul><li>对于<code>static</code>函数，其没有this指针，不能访问类的普通成员与成员函数，只能访问类的静态成员；</li><li>对于<code>static</code>成员，需要在定义时初始化，且不能在头文件中初始化，初始化方法为：<code>&lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt;=&lt;值&gt;</code>；</li><li>对于<code>public</code>类型的<code>static</code>成员，可用<code>&lt;类名&gt;::&lt;静态成员名&gt;</code>的方法在非类的对象中引用静态成员，进一步说明了静态成员属于类而非对象；</li><li>子类和父类的同名<code>static</code>成员或方法，调用哪一个看作用域。</li></ul><h2 id="虚函数调用"><a href="#虚函数调用" class="headerlink" title="虚函数调用"></a>虚函数调用</h2><p>今天对虚函数的调用有疑问，主要疑问为：类方法对虚函数的调用到底调用的是哪个。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">go_out</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"out A"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</div><div class="line">go_out();</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">go_out</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"out B"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> B&#123;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">go_out</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"out C"</span> &lt;&lt;<span class="built_in">endl</span>;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</div><div class="line">C *cc = <span class="keyword">new</span> C();</div><div class="line">cc-&gt;test();</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>实验发现，输出结果为<code>out C</code>。<br>其实这符合虚函数的调用原理，毕竟test是通过指向C类型的指针调用的，改为<code>B *cc = new C();</code>输出结果也一样。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;私有构造函数&quot;&gt;&lt;a href=&quot;#私有构造函数&quot; class=&quot;headerlink&quot; title=&quot;私有构造函数&quot;&gt;&lt;/a&gt;私有构造函数&lt;/h2&gt;&lt;p&gt;首先，private成员与方法只能被类内部的方法访问，而protected成员与方法只能被类内部或派生类内部
      
    
    </summary>
    
      <category term="记录" scheme="http://yoursite.com/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="多态" scheme="http://yoursite.com/tags/%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>typedef与函数指针</title>
    <link href="http://yoursite.com/2018/07/26/typedef%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"/>
    <id>http://yoursite.com/2018/07/26/typedef函数指针/</id>
    <published>2018-07-25T22:44:00.000Z</published>
    <updated>2018-07-29T02:08:11.103Z</updated>
    
    <content type="html"><![CDATA[<h2 id="typedef基本"><a href="#typedef基本" class="headerlink" title="typedef基本"></a>typedef基本</h2><p>今日在代码中看到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(ISSCALLBACK *Proc_MVWOnMsgProc)</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">void</span>*         pUsrArg,     <span class="comment">/* [In] User defined parameter */</span></span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        uMsg,        <span class="comment">/* [In] The message identifier */</span></span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        wParam,      <span class="comment">/* [In] Message additional information */</span></span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">void</span>*         lParam        <span class="comment">/* [In] Message additional information */</span></span></span></div><div class="line"><span class="function"><span class="params">)</span></span>;</div></pre></td></tr></table></figure><p>一时之间无法理解其意义，发觉自己对<code>typedef</code>以及函数指针有些生疏，现在重新整理二者用法。</p><p>首先看一个变量定义与<code>typedef</code>的区别：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> number1;<span class="comment">//number为 unsigned int 型</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> number2;<span class="comment">//使用number2定义的变量为 unsigned int 型</span></div><div class="line"></div><div class="line"><span class="keyword">enum</span> ISS_TTS_CODEPAGE &#123;</div><div class="line">    ISS_TTS_CODEPAGE_GBK = <span class="number">936</span>,</div><div class="line">    ISS_TTS_CODEPAGE_UTF16LE = <span class="number">1200</span>,</div><div class="line">    ISS_TTS_CODEPAGE_UTF8 = <span class="number">65001</span></div><div class="line">&#125; ISSTTSCodePage;</div><div class="line"><span class="comment">//ISSTTSCodePage为ISS_TTS_CODEPAGE类型的enum</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> ISS_TTS_CODEPAGE &#123;</div><div class="line">    ISS_TTS_CODEPAGE_GBK = <span class="number">936</span>,</div><div class="line">    ISS_TTS_CODEPAGE_UTF16LE = <span class="number">1200</span>,</div><div class="line">    ISS_TTS_CODEPAGE_UTF8 = <span class="number">65001</span></div><div class="line">&#125; ISSTTSCodePage2;</div><div class="line"><span class="comment">//ISSTTSCodePage定义的变量为ISS_TTS_CODEPAGE类型的enum</span></div><div class="line">ISSTTSCodePage2 someitem;</div></pre></td></tr></table></figure><p>可以看出原有的定义加上<code>typedef</code>就将其转化为定义原定义的类型。</p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>再来说函数指针，举最简单的例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> (*PTRFUN)(<span class="keyword">int</span>);</div></pre></td></tr></table></figure></p><p>表示<code>PTRFUN</code>指向一个形参为<code>int</code>返回值为<code>char</code>的函数</p><p>若是加上<code>typedef</code>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">char</span> <span class="params">(*PTRFUN)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</div></pre></td></tr></table></figure></p><p>则可以用<code>PTRFUN</code>来定义函数，特别是用在回调函数上：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">callbackfunc</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">bool</span> torf, PTRFUN somefunc)</span></span>;</div></pre></td></tr></table></figure></p><h2 id="typedef数组指针"><a href="#typedef数组指针" class="headerlink" title="typedef数组指针"></a>typedef数组指针</h2><p>今天又在代码中看到：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE (3200)</span></div><div class="line"><span class="keyword">typedef</span> byte BUFFER[BUFSIZE];</div><div class="line">BUFFER *m_pBuffer = <span class="keyword">new</span> BUFFER[BUFNUM];</div></pre></td></tr></table></figure></p><p>有点迷惑<code>new</code>出来的是<code>byte[10][3200]</code>还是<code>byte[3200][10]</code>。<br>其实看<code>m_pBuffer</code>的类型即可，将<code>*m_pBuffer</code>替换到typedef定义中，即是：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">byte *m_pBuffer[BUFSIZE];</div></pre></td></tr></table></figure></p><p>即<code>m_pBuffer</code>为指向<code>byte[3200]</code>的指针，可见new出来的一定是<code>byte[10][3200]</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;typedef基本&quot;&gt;&lt;a href=&quot;#typedef基本&quot; class=&quot;headerlink&quot; title=&quot;typedef基本&quot;&gt;&lt;/a&gt;typedef基本&lt;/h2&gt;&lt;p&gt;今日在代码中看到：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp
      
    
    </summary>
    
      <category term="知识" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu安装后要做的一些事</title>
    <link href="http://yoursite.com/2017/11/06/ubuntu%E5%AE%89%E8%A3%85%E5%90%8E%E8%A6%81%E5%81%9A%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/"/>
    <id>http://yoursite.com/2017/11/06/ubuntu安装后要做的一些事/</id>
    <published>2017-11-05T22:00:00.000Z</published>
    <updated>2017-11-05T15:17:12.704Z</updated>
    
    <content type="html"><![CDATA[<p>ubuntu我重装了不知道有多少遍，每次重装时都要重复进行一些操作，这次干脆将这些常用操作记录下来，以便下次重装时查询。</p><h2 id="更换软件源"><a href="#更换软件源" class="headerlink" title="更换软件源"></a>更换软件源</h2><blockquote><p>本条在八个月之后就会无效，也算是毕业的一点遗憾。</p></blockquote><ul><li><p>编辑源：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo gedit /etc/apt/sources.list</div></pre></td></tr></table></figure><p>  将原内容更换为：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">deb https://linux.xidian.edu.cn/mirrors/ubuntu/ xenial main restricted universe multiverse</div><div class="line">deb https://linux.xidian.edu.cn/mirrors/ xenial-security main restricted universe multiverse</div><div class="line">deb https://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-updates main restricted universe multiverse</div><div class="line">deb https://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-proposed main restricted universe multiverse</div><div class="line">deb https://linux.xidian.edu.cn/mirrors/ubuntu/ xenial-backports main restricted universe multiverse</div><div class="line">deb-src https://linux.xidian.edu.cn/mirrors/ubuntu/ xenial main restricted universe multiverse</div><div class="line">deb-src https://linux.xidian.edu.cn/mirrors/ xenial-security main restricted universe multiverse</div><div class="line">deb-src https://linux.xidian.edu.cn/mirrors/ xenial-updates main restricted universe multiverse</div><div class="line">deb-src https://linux.xidian.edu.cn/mirrors/ xenial-proposed main restricted universe multiverse</div><div class="line">deb-src https://linux.xidian.edu.cn/mirrors/ xenial-backports main restricted universe multiverse</div></pre></td></tr></table></figure><p>  这里要感谢<a href="https://linux.xidian.edu.cn/" target="_blank" rel="external">西电开源社区</a>的无私奉献，让我们在校内能够享受速度快且免流的软件源。</p></li><li><p>更新源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt update</div></pre></td></tr></table></figure></li></ul><h2 id="翻墙"><a href="#翻墙" class="headerlink" title="翻墙"></a>翻墙</h2><blockquote><p>不翻墙，毋宁死。</p></blockquote><ul><li><p>安装miredo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt install miredo</div></pre></td></tr></table></figure></li><li><p>测试是否有ipv6连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ping6 ipv6.baidu.com</div></pre></td></tr></table></figure><p>  不知道什么原因，每次开机都需要重新启动miredo，非常麻烦，<strong>本条待编辑</strong>。</p></li><li><p>安装ss</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sudo add-apt-repository ppa:hzwhuang/ss-qt5</div><div class="line">$ sudo apt-get update</div><div class="line">$ sudo apt-get install shadowsocks-qt5</div></pre></td></tr></table></figure></li><li><p>配置chrome<br>在ss配置完毕后，以代理模式打开chrome：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ google-chrome --proxy-server=socks5://127.0.0.1:1080</div></pre></td></tr></table></figure><p>  登录google帐号，同步插件与书签，并导入proxy配置。</p></li></ul><h2 id="安装rEFInd"><a href="#安装rEFInd" class="headerlink" title="安装rEFInd"></a>安装rEFInd</h2><p>双系统用grub引导可以说是非常丑，紫不拉叽的背景，无法更改的界面。于是选择<a href="http://www.rodsbooks.com/refind/installing.html" target="_blank" rel="external">rEFInd</a>作为双系统的引导。  </p><ul><li><p>安装:<br>执行脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./refind-install</div></pre></td></tr></table></figure><p>  或者使用apt安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-add-repository ppa:rodsmith/refind</div><div class="line">$ sudo apt-get update</div><div class="line">$ sudo apt-get install refind</div></pre></td></tr></table></figure><p>  安装后路径为：<code>/boot/efi/EFI/refind</code></p></li><li><p>安装主题：<br><code>/boot/efi/EFI/refind</code>目录下新建themes文件夹，并将rEFInd-minimal文件夹复制进去。<br>将代码<code>include themes/rEFInd-minimal/theme.conf</code>添加到<code>refind.conf</code>文件末尾。<br>更改下面几个选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">timeout 2             <span class="comment">#超时</span></div><div class="line">resolution 1920 1080  <span class="comment">#分辨率</span></div><div class="line">max_tags 3            <span class="comment">#最大图标个数</span></div></pre></td></tr></table></figure></li><li><p>跳过grub引导<br>将文件<code>/etc/default/grub</code>中的<code>#GRUB_HIDDEN_TIMEOUT=0</code>注释去掉，就会跳过grub引导，直接进入系统。</p></li></ul><h2 id="解决ubuntu-windows时间不一致的问题"><a href="#解决ubuntu-windows时间不一致的问题" class="headerlink" title="解决ubuntu/windows时间不一致的问题"></a>解决ubuntu/windows时间不一致的问题</h2><ul><li>一行指令搞定：<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ timedatectl <span class="built_in">set</span>-local-rtc 1 --adjust-system-clock</div></pre></td></tr></table></figure></li></ul><h2 id="安装unity主题"><a href="#安装unity主题" class="headerlink" title="安装unity主题"></a>安装unity主题</h2><p>unity有许多类mac主题与扁平化图标，这里选择Flatabulous主题与ultra-flat图标。</p><ul><li><p>unity-tweak-tool<br>首先安装unity-tweak-tool，管理主题与图标，并进行一些unity的设置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt install unity-tweak-tool</div></pre></td></tr></table></figure></li><li><p>Flatabulous主题:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sudo add-apt-repository ppa:noobslab/themes</div><div class="line">$ sudo apt-get update</div><div class="line">$ sudo apt-get install flatabulous-theme</div></pre></td></tr></table></figure></li><li><p>ultra-flat图标</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sudo add-apt-repository ppa:noobslab/icons</div><div class="line">$ sudo apt-get update</div><div class="line">$ sudo apt-get install ultra-flat-icons</div></pre></td></tr></table></figure><p>  效果如下：<br><img src="/img/xiaoguo.png" alt="">  </p><h2 id="常用软件安装"><a href="#常用软件安装" class="headerlink" title="常用软件安装"></a>常用软件安装</h2><blockquote><p>linux下自然是用来学习与写代码的，下面这几个常用软件也是必装的。</p></blockquote></li><li><p>sublime text</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#安装GPG key</span></div><div class="line">$ wget -qO - https://download.sublimetext.com/sublimehq-pub.gpg | sudo apt-key add -</div><div class="line"><span class="comment">#确保apt工作在https源的模式</span></div><div class="line">$ sudo apt-get install apt-transport-https</div><div class="line"><span class="comment">#使用stable方式安装</span></div><div class="line">$ <span class="built_in">echo</span> <span class="string">"deb https://download.sublimetext.com/ apt/stable/"</span> | sudo tee</div><div class="line">$ /etc/apt/sources.list.d/sublime-text.list</div><div class="line"><span class="comment">#更新源并安装</span></div><div class="line">$ sudo apt-get update</div><div class="line">$ sudo apt-get install sublime-text</div></pre></td></tr></table></figure></li><li><p>spyder</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ apt install spyder</div></pre></td></tr></table></figure></li><li><p>mysql</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#第一条指令安装过程中需要设定root密码</span></div><div class="line">$ sudo apt install mysql-server</div><div class="line">$ sudo apt install mysql-client</div><div class="line">$ sudo apt install libmysqlclient-dev</div><div class="line"><span class="comment">#可视化工具</span></div><div class="line">$ sudo apt install mysql-workbench</div></pre></td></tr></table></figure></li><li><p>wps<br>unbuntu自带的libre与MS office之间有许多兼容性问题，所以卸载libre，安装wps<br>卸载libre：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get remove libreoffice-common</div></pre></td></tr></table></figure><p>  安装完wps后会有字体缺失问题，下载<a href="https://pan.baidu.com/s/1eS6xIzo" target="_blank" rel="external">字体文件</a>，将目录中所有文件复制到<code>/usr/share/fonts</code>下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo cp mtextra.ttf  symbol.ttf  WEBDINGS.TTF  wingding.ttf  WINGDNG2.ttf  WINGDNG3.ttf  /usr/share/fonts</div></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ubuntu我重装了不知道有多少遍，每次重装时都要重复进行一些操作，这次干脆将这些常用操作记录下来，以便下次重装时查询。&lt;/p&gt;
&lt;h2 id=&quot;更换软件源&quot;&gt;&lt;a href=&quot;#更换软件源&quot; class=&quot;headerlink&quot; title=&quot;更换软件源&quot;&gt;&lt;/a&gt;更换软
      
    
    </summary>
    
      <category term="记录" scheme="http://yoursite.com/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>seafile部署记录</title>
    <link href="http://yoursite.com/2017/11/04/2017-11-03-seafile/"/>
    <id>http://yoursite.com/2017/11/04/2017-11-03-seafile/</id>
    <published>2017-11-03T17:23:35.000Z</published>
    <updated>2017-11-05T14:55:39.201Z</updated>
    
    <content type="html"><![CDATA[<p>近日在网上看到vps可以部署私有云存储，正好手头上的vps除了SS搭梯子没有别的用途，遂在网上寻找云存储搭建教程。最后决定使用<a href="&quot;https://www.xiaoz.me/archives/8480&quot;">xiaoz</a>的一键搭建脚本。  </p><h3 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h3><ul><li>CenOS 7 64位  </li><li>Python &gt;= 2.7</li><li>SqLite 3  </li></ul><hr><h3 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h3><p>输入以下命令以进行安装  </p><pre><code class="bash">$ yum -y install wget  $ wget https://raw.githubusercontent.com/helloxz/seafile/<span class="variable">$master</span>/install_seafile.sh  $ chmod +x install_seafile.sh &amp;&amp; ./install_seafile.sh</code></pre><blockquote><p>其中最后一条命令可以用于卸载。</p></blockquote><p>安装过程跟着脚本走就可以，注意填写<em>server’s ip or domain</em>时不要瞎填，填自己vps的公网ip即可。<br>安装完成后使用<code>http://公网ip:8000</code>进行访问。</p><hr><h3 id="维护相关"><a href="#维护相关" class="headerlink" title="维护相关"></a>维护相关</h3><p>官方帮助文档：<a href="https://manual-cn.seafile.com/" target="_blank" rel="external">https://manual-cn.seafile.com/</a><br>客户端下载：<a href="https://www.seafile.com/download/" target="_blank" rel="external">https://www.seafile.com/download/</a>  </p><p>使用以下命令维护：</p><pre><code class="bash"><span class="comment">#安装目录  </span>/home/MyCloud  <span class="comment">#启动服务  </span>/home/MyCloud/seafile-server/seafile.sh start  /home/MyCloud/seafile-server/seahub.sh start  <span class="comment">#停止服务  </span>/home/MyCloud/seafile-server/seafile.sh stop  /home/MyCloud/seafile-server/seahub.sh stop  <span class="comment">#重置管理员账号   </span>/home/MyCloud/seafile-server/reset-admin.sh</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;近日在网上看到vps可以部署私有云存储，正好手头上的vps除了SS搭梯子没有别的用途，遂在网上寻找云存储搭建教程。最后决定使用&lt;a href=&quot;&amp;quot;https://www.xiaoz.me/archives/8480&amp;quot;&quot;&gt;xiaoz&lt;/a&gt;的一键搭建脚本。
      
    
    </summary>
    
      <category term="VPS" scheme="http://yoursite.com/categories/VPS/"/>
    
    
      <category term="toy" scheme="http://yoursite.com/tags/toy/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/11/03/hello-world/"/>
    <id>http://yoursite.com/2017/11/03/hello-world/</id>
    <published>2017-11-03T12:00:00.000Z</published>
    <updated>2017-11-04T13:53:24.583Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开坑感言"><a href="#开坑感言" class="headerlink" title="开坑感言"></a>开坑感言</h3><p>终于在拖延了这么久之后，用了两个晚上和一个下午把这个博客搭建起来。  </p><p>其实之前并没有写博客的习惯，但经常有一些事情，还是希望记录下来。有时有些想法转瞬即逝，但却没有及时抓住，过几日就忘得差不多了；有些脚本、代码或者方法，不记录下来，等再次遇到又要求助于百度，实在是麻烦；一本书看毕，无论是小说还是技术书籍，总有些收获，也能写上一两篇文章。  </p><p>本博客托管于github，其实基本不会有什么人来访问（<em>因为我github就没怎么用过</em>），主要就是记录给自己看，相当于一个云笔记了。<a href="https://hexo.io/zh-cn/" target="_blank" rel="external">hexo</a>的主题还是很给力的，非常美观，自定义程度高，多少也能接触一些前端技术。正文使用<a href="http://wowubuntu.com/markdown/" target="_blank" rel="external">markdown</a>编写，省力又有趣，何乐而不为。</p><p>总之，第一篇博客测试的成分居多，就这样吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;开坑感言&quot;&gt;&lt;a href=&quot;#开坑感言&quot; class=&quot;headerlink&quot; title=&quot;开坑感言&quot;&gt;&lt;/a&gt;开坑感言&lt;/h3&gt;&lt;p&gt;终于在拖延了这么久之后，用了两个晚上和一个下午把这个博客搭建起来。  &lt;/p&gt;
&lt;p&gt;其实之前并没有写博客的习惯，但经常有一
      
    
    </summary>
    
      <category term="闲聊" scheme="http://yoursite.com/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="想法" scheme="http://yoursite.com/tags/%E6%83%B3%E6%B3%95/"/>
    
  </entry>
  
</feed>
